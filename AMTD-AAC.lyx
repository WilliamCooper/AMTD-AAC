#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass copernicus
\begin_preamble
\usepackage{lineno}
\linenumbers
\end_preamble
\options amt,bookmarks=false,unicode=true
\use_default_options true
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language british
\language_package auto
\inputencoding default
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 0
\use_package amssymb 0
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\series bold
Note:
\series default
 The journal where you want to sumit is specified in the document class
 options of this file.
 The allowed jounal abbreviations are listed in the file 
\family sans
Copernicus_Latex_Manual.pd
\family default
f that is part of the copernicus LaTeX-package.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
To prepare for Discussions format, use copernicus article class but AMTD
 for journal, then edit the latex file (exported via pdflatex option) to
 change from copernicus to copernicus_discussions.
 Turning off color in PDF properties for links causes a pdflatex failure.
 Run pdflatex AMTDdraft twice, add bibtex AMTDdraft, then another pdflatex
 AMTDdraft to get the PDF file.
\end_layout

\end_inset


\end_layout

\begin_layout Title
Algorithms for correcting measurements of attitude angles
\end_layout

\begin_layout Author
W.
 A.
 Cooper
\end_layout

\begin_layout Affiliation
National Center for Atmospheric Research, Boulder CO, U.
 S.
 A.
\end_layout

\begin_layout Running title
Corrections for INS attitude-angle errors
\end_layout

\begin_layout Running author
W.
 A.
 Cooper
\end_layout

\begin_layout Correspondence
W.
 A.
 Cooper
\begin_inset Newline newline
\end_inset

(cooperw@ucar.edu)
\end_layout

\begin_layout Abstract
Many systems for measuring wind on research aircraft rely on inertial navigation
 systems for the measurement of pitch, roll, and heading, and uncertainties
 in those measurements are often the dominant source of uncertainty in measureme
nts of wind.
 Simple algorithms that can improve those measurements in data sets already
 collected or in future measurement campaigns are developed here.
 It is demonstrated that with those algorithms uncertainties in these attitude
 angles can be reduced to 0.01
\begin_inset Formula $^{\circ}$
\end_inset

 or less, and that this leads to a significant reduction in uncertainty
 associated with the measurements of wind.
 The use of Global Positioning System receivers to improve these measurements
 has a long history and the general basis for the approach developed here
 is not new, but the specific implementation is particularly suited to improving
 measurement capabilities for atmospheric research.
 Code for implementing these algorithms, provided as supplemental material,
 is developed for the data sets archived and collected by the Research Aviation
 Facility of the National Center for Atmospheric Research, but it could
 be applied to other data sources also.
\end_layout

\begin_layout Introduction
\begin_inset Note Note
status open

\begin_layout Plain Layout
Keep entries with green labels empty!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inertial navigation systems (INSs) used, e.g., on research aircraft provide
 measurements of the pitch, roll, and heading of the aircraft, here called
 the attitude angles of the aircraft.
 Errors in these angles can arise from many sources, but it appears that
 dominant sources are errors in initial alignment and errors that result
 from in-flight drift, often associated with horizontal accelerations.
 These errors often are the dominant errors in measurements of wind from
 research aircraft.
 The examples here are drawn from data collected using the NSF/NCAR Gulfstream
 V research aircraft, and at typical flight speeds of that aircraft an uncertain
ty in pitch of 0.05
\begin_inset Formula $^{\circ}$
\end_inset

, the specification for the INS on that aircraft, leads to an uncertainty
 in vertical wind of about 0.2
\begin_inset space ~
\end_inset

m/s.
 A separate analysis of uncertainty for that measurements (
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"

\end_inset

) shows that uncertainty in pitch is the dominant source of uncertainty
 in measured vertical wind.
 The uncertainty in heading is still larger and leads to a proportionately
 larger uncertainty in the lateral component of the horizontal wind.
 Therefore, correcting for these errors can lead to significant improvement
 in the measurements of wind.
\end_layout

\begin_layout Standard
The standard method for correcting such errors is via a Kalman filter, where
 the error sources are represented by an error model and the corrected set
 of measurements is obtained by detecting and providing feedback for errors
 determined by comparing the INS measurements to some reference such as
 measurements from a Global Positioning System (GPS) receiver.
 This approach is discussed in many books and articles, including for example
 
\begin_inset CommandInset citation
LatexCommand citet
key "noureldin2013fundamentals"

\end_inset

, 
\begin_inset CommandInset citation
LatexCommand citet
key "groves2013PrinciplesGNSS"

\end_inset

, and additional references cited therein.
 The Kalman filter requires extensive information regarding the characteristics
 of the measuring system and can be complex.
 While this approach provides good results, it is often difficult to know
 what corrections are made, how good they are, and how they relate to the
 flight conditions.
 Incorporation of a good Kalman filter requires either a substantial development
 project or an expensive addition to the INS itself.
 
\end_layout

\begin_layout Standard
The intent of this note is to provide alternative corrections for all three
 attitude angles on the basis of relatively simple comparisons between measureme
nts available from the combination of an INS and a GPS receiver.
 These corrections can be applied to archived data and so can lead to improvemen
ts in datasets collected in past as well as future projects.
 In the case of pitch and roll, the solution relies on observation of the
 derivatives in the errors in ground-speed components and position, which
 arise primarily from errors in those angles.
 For heading, the accelerations measured by the INS are compared to those
 determined by differentiating the GPS-provided ground-speed components.
 This difference is dependent on the error in heading because the accelerations
 are measured in the body frame of the aircraft (here called
\emph on
 
\emph default
the 
\begin_inset Formula $a$
\end_inset

-frame), and translation to an Earth-reference frame (or 
\emph on
l
\emph default
-frame) involves the heading.
 An error in heading results in a difference between the two sets of measured
 accelerations, and that difference can be used to estimate the error in
 heading.
 As developed here, all three corrections are applied to measurements after
 acquisition, not during recording, to be able to use algorithms that smooth
 measurements over centered intervals.
 This also makes it possible to correct archived data as long as the full
 set of INS measurements including accelerations and measurements of ground-spee
d by both an INS and a GPS receiver are available.
\end_layout

\begin_layout Standard
A technical note discussing the uncertainty in measurements of wind for
 this research aircraft (
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"

\end_inset

) provides more detail regarding the instrumentation and calibration of
 the wind-sensing system.
 The appendix to this paper summarizes key results from that technical note.
 That reference also provides support for the entries in the tables of the
 appendix to this note, where the uncertainty in wind measurement is summarized.
\end_layout

\begin_layout Section
Correcting the pitch and roll
\begin_inset CommandInset label
LatexCommand label
name "sec:Correcting-the-pitch"

\end_inset


\end_layout

\begin_layout Subsection
The basis for the correction
\begin_inset CommandInset label
LatexCommand label
name "sub:Sect2.1"

\end_inset


\end_layout

\begin_layout Standard
An inertial system aligns during initialization to detect the local vertical
 direction and then calculates the new vertical direction as the aircraft
 moves (changing the local vertical direction) and accelerates (which can
 cause gyros to precess).
 Any mis-alignment present at initialization persists but also will oscillate
 and will cause errors in roll and pitch to mix as the aircraft changes
 flight direction.
 For the inertial system used on the NSF/NCAR GV, the standard uncertainty
 associated with this measurement is 0.05
\begin_inset Formula $^{\circ}$
\end_inset

 in both roll and pitch for flight duration of a few hours, and the error
 often increases during the flight as heading errors and accelerometer biases
 affect the results.
 
\end_layout

\begin_layout Standard
The work of Schuler (
\begin_inset CommandInset citation
LatexCommand cite
key "Schuler1923"

\end_inset

) showed that coupling among some of these error sources leads to limits
 on the growth of errors and to simultaneous oscillations in some of the
 measurement errors.
 In particular, an error in pitch leads to an error in horizontal acceleration
 because gravity is resolved to have a horizontal component, and integration
 of that error in horizontal acceleration leads to a position error that
 grows so as to compensate for the false component of acceleration arising
 from the original error in pitch.
 However, when the error in pitch is reduced to zero, errors in position
 and velocity have been accumulated and those lead to growth of the error
 in pitch in the direction opposite to the original error.
 The result is a Schuler oscillation having a period of 
\begin_inset Formula $T_{Sch}=(R_{e}/g)^{0.5}/(2\pi)\approx5064\thinspace s$
\end_inset

 or 84.4
\begin_inset space \thinspace{}
\end_inset

min, where 
\begin_inset Formula $R_{e}$
\end_inset

 is the radius of the Earth and 
\begin_inset Formula $g$
\end_inset

 the acceleration of gravity.
 
\end_layout

\begin_layout Standard
The existence of this coupling allows estimation of the pitch error if the
 error in horizontal acceleration is known.
 That is the case if, in addition to the INS, there is a GPS receiver that
 can provide high-quality measurements of Earth-relative velocity.
 Modern GPS receivers, especially if they incorporate differential-GPS correctio
ns or ionispheric corrections, produce velocity measurements that have remarkabl
y low uncertainty, often a few cm/s, so these can be considered a standard
 against which to compare the corresponding IRS-measured velocities.
 The difference between ground-speed components from the two systems thus
 determines the error in INS-measured velocity and, after differentiation,
 the error in horizontal acceleration.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization-pitch,echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ReloadData <- FALSE
\end_layout

\begin_layout Plain Layout

ReloadData <- TRUE
\end_layout

\begin_layout Plain Layout

require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
\end_layout

\begin_layout Plain Layout

require(ggplot2)
\end_layout

\begin_layout Plain Layout

require(grid)
\end_layout

\begin_layout Plain Layout

library(knitr)
\end_layout

\begin_layout Plain Layout

require(ggthemes)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.width=6, fig.height=5, fig.loc="center", digits=4)
\end_layout

\begin_layout Plain Layout

thisFileName <- "AttitudeAngleNote"
\end_layout

\begin_layout Plain Layout

setwd("~/RStudio/AMTD-AAC")
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()
\end_layout

\begin_layout Plain Layout

Flight <- "ff02" 				# XXX change this
\end_layout

\begin_layout Plain Layout

Project = "DEEPWAVE"			 # XXX change this
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory,Project,Project,Flight)
\end_layout

\begin_layout Plain Layout

VarNames <- c("BLATA", "BLONGA", "BNORMA", "VNS", "VEW", "VSPD", "GGVNS",
 "GGVEW", 
\end_layout

\begin_layout Plain Layout

              "GGVSPD", "LAT", "LON", "ALT", "THDG", "PITCH", "ROLL") 
\end_layout

\begin_layout Plain Layout

SaveRData1 <- sprintf("DataFrames/%s1.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF (fname, standardVariables(VarNames))		
\end_layout

\begin_layout Plain Layout

  save(Data, file=SaveRData1)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData1)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Cradeg <- pi / 180
\end_layout

\begin_layout Plain Layout

source ("~/RStudio/Ranadu/R/ShiftInTime.R")
\end_layout

\begin_layout Plain Layout

source("~/RStudio/Ranadu/R/XformLA.R")
\end_layout

\begin_layout Plain Layout

source ("~/RStudio/Ranadu/R/PitchCorrection.R")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If 
\begin_inset Formula $a_{n}=a_{n}^{*}+\delta a_{n}$
\end_inset

 where 
\begin_inset Formula $a_{n}^{*}$
\end_inset

 is the true northward acceleration of the aircraft and 
\begin_inset Formula $\delta a_{n}$
\end_inset

 is the erroneous acceleration that results from pitch and displacement
 errors, then the error in acceleration is given by
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\delta a_{n}^{(l)}=-g\delta\theta^{(l)}\,\,\,.\label{eq:delta-an}
\end{equation}

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
need to include 
\begin_inset Formula $\delta\lambda$
\end_inset

 term, not negl.
 vs 
\begin_inset Formula $\delta\theta$
\end_inset


\end_layout

\end_inset

where 
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula $\delta\lambda$
\end_inset

 is the error in latitude and
\end_layout

\end_inset

 
\begin_inset Formula $\delta\theta^{(l)}$
\end_inset

 is the error in pitch.
 The superscripts 
\begin_inset Formula $(l)$
\end_inset

 denote that these pitch and acceleration errors are those present in an
 Earth reference frame or 
\begin_inset Formula $l$
\end_inset

-frame, often called the ENU frame, where the axes are respectively east,
 north, and up.
 Then the error in measured northward acceleration provides a direct measure
 of the error in pitch:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\theta^{(l)}=-\frac{1}{g}\frac{d(\delta v_{n}^{(l)})}{dt}\,\,\,.\label{eq:full-delta-pitch}
\end{equation}

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
\frac{d(\delta v_{n})}{dt}=-g\delta\theta^{(l)}\label{eq:delta-vn-dot}
\end{equation}

\end_inset

leads to the standard Schuler oscillation with angular frequency 
\begin_inset Formula $\omega=\sqrt{g/R_{e}}\simeq0.00124$
\end_inset


\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
\frac{d(\delta\theta^{(l)})}{dt}=\frac{\delta v_{n}}{R_{e}}=-\frac{1}{g}\frac{d^{2}(\delta v_{n})}{dt^{2}}\label{eq:delta-theta-dot}
\end{equation}

\end_inset

which has the solution:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta v_{n}=V_{n}\cos(\omega t+\zeta_{n})\label{eq:delta-vn-solution}
\end{equation}

\end_inset

where 
\begin_inset Formula $\omega=\sqrt{g/R_{e}}\simeq0.00124$
\end_inset

 is the Schuler angular velocity.
 
\end_layout

\end_inset

 The error in the north component of the velocity and the error in pitch
 therefore both oscillate with the Schuler period.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Integrating in time gives
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta x_{n}=\int\delta v_{n}dt=\frac{V_{n}}{\omega}\sin(\omega t+\zeta_{n})\label{eq:delta-xn-solution}
\end{equation}

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Because 
\begin_inset Formula $\delta v_{n}$
\end_inset

is measurable by comparison to measurements from a GPS receiver, the error
 in pitch can be found from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:full-delta-pitch"

\end_inset

) and the analogous equation for the 
\begin_inset Formula $l$
\end_inset

-frame error in roll, 
\begin_inset Formula $\delta\phi^{(l)}$
\end_inset

:
\begin_inset Foot
status open

\begin_layout Plain Layout
The different signs arise from the different definitions of the angles,
 where a positive pitch error represents a rotation of the platform axis
 in the negative 
\begin_inset Formula $y$
\end_inset

-axis direction but a positive roll error corresponds to a platform rotation
 in the positive 
\begin_inset Formula $x$
\end_inset

-axis direction.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
\delta\theta^{(l)}=-\frac{1}{g}\frac{d(V_{n}\cos(\omega t+\zeta_{n})}{dt}=\frac{V_{n}\omega}{g}\sin(\omega t+\zeta_{n})\label{eq:solution-delta-theta-1}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout
Analogous equations lead to a similar coupling between the roll angle and
 the east component of the ground velocity:
\end_layout

\begin_layout Plain Layout
\begin_inset Formula 
\begin{equation}
\delta\phi^{(l)}=-\frac{V_{e}\omega}{g}\sin(\omega t+\zeta_{e})\label{eq:solution-delta-phi-1}
\end{equation}

\end_inset

where 
\begin_inset Formula $\phi$
\end_inset

 is the roll angle and 
\begin_inset Formula $V_{e}$
\end_inset

 and 
\begin_inset Formula $\zeta_{e}$
\end_inset

 are determined from fits to the observed error 
\begin_inset Formula $\delta v_{e}=\mathrm{VEW-GGVEW}$
\end_inset

.
 The errors can be determined directly from the time-derivatives of the
 error terms in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-vn-dot"

\end_inset

) and the analogous equation for roll, restated as:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\delta\phi^{(l)} & = & \frac{1}{g}\frac{d(\delta v_{e}^{(l)})}{dt}\,\,\,.\label{eq:delta-phi}
\end{eqnarray}

\end_inset

The differentiated errors in the components of the aircraft ground-speed
 and the errors in position thus can provide estimates for corrections to
 be applied to the measurements of pitch and roll.
 Because this correction relies on the observable effects of the errors
 on velocity, it is not sensitive to the source of the error, whether it
 arises from misalignment before flight, bias errors in the INS gyros, or
 other sources except for these exceptions: (i) an error in measured acceleratio
n from the accelerometers that contributes to the velocity errors in a way
 not dependent on the pitch or roll errors; and (ii) a minor dependence
 on error in heading that arises when the pitch and roll errors in the Earth-rel
ative 
\begin_inset Formula $l$
\end_inset

-frame are transformed to the reference frame of the aircraft.
 The latter is negligible for normal heading errors, but the former can
 cause increasing amplitude or drift of the velocity errors.
 Figures to be shown below of the observed errors in ground-speed components
 suggest relatively small changes in the amplitude of the Schuler oscillation
 during most flights, as would be expected if the accelerometer errors make
 only small contributions to the velocity errors.
\end_layout

\begin_layout Standard
In general an additional transformation of angles is needed to obtain the
 pitch and roll errors in the aircraft reference frame, which will here
 be called the 
\begin_inset Formula $a$
\end_inset

-frame.
 The 
\begin_inset Formula $a$
\end_inset

-frame differs from the 
\begin_inset Formula $b$
\end_inset

-frame or body frame often discussed in the inertial-navigation literature
 by having 
\begin_inset Formula $\hat{x}$
\end_inset

 and 
\begin_inset Formula $\hat{y}$
\end_inset

 axes interchanged and the 
\begin_inset Formula $\hat{z}$
\end_inset

 axis reversed to be downward, as is conventional for aircraft.
\begin_inset Note Note
status open

\begin_layout Plain Layout
The solution to (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:full-delta-pitch"

\end_inset

) is obtained by writing the position error as 
\begin_inset Formula $\delta y=A\cos(\omega t+\gamma)$
\end_inset

 where 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $\gamma$
\end_inset

 are respectively the amplitude and phase of the oscillation and 
\begin_inset Formula $\omega$
\end_inset

=
\begin_inset Formula $\sqrt{g/R_{e}}$
\end_inset

 is the angular frequency of the Schuler oscillation.
 Then the acceleration error is (
\begin_inset Formula $g/R_{e})\delta y$
\end_inset

 and the latitude error is 
\begin_inset Formula $\delta y/R_{e}$
\end_inset

, leading to a pitch error of 
\begin_inset Formula $\delta\theta=-\delta y/R_{e}$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
An example
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<v-errors-straight-leg, fig.height=5.5, fig.lp="fig:",fig.cap="Top: Errors
 in the IRS measurements of the northward and eastward components of groundspeed
 ($V_n^{(IRS)}$ and $V_e^{(IRS)}$) as determined by comparison to measurements
 from a GPS receiver ($V_n^{(GPS)}$ and $V_e^{(GPS)}$) for DEEPWAVE flight
 ff02, a ferry flight starting on 1 June 2014 and traveling from Hawaii
 to Pago-Pago.
 Bottom: Errors in pitch ($
\backslash

\backslash
delta
\backslash

\backslash
theta$) and roll ($
\backslash

\backslash
delta
\backslash

\backslash
phi$) as obtained from (
\backslash

\backslash
ref{eq:full-delta-pitch}) and (
\backslash

\backslash
ref{eq:delta-phi}).", include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D <- Data[Data$TASX > 130., ]
\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol = 1), widths = 1, heights = c(5,6))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

plotWAC (D$Time, D$VNS-D$GGVNS, ylab="error [m/s]", ylim=c(-2.5,3.5))
\end_layout

\begin_layout Plain Layout

Z <- lineWAC (D$Time, D$VEW-D$GGVEW, col='darkgreen')
\end_layout

\begin_layout Plain Layout

legend ('top', legend=c(expression(paste('(',V[e]^(IRS),'-',V[e]^(GPS),')')),
 expression(paste('(',V[n]^(IRS),'-',V[n]^(GPS),')'))), lwd=2, col=c('darkgreen'
, 'blue'), text.col=c('darkgreen', 'blue'), cex=0.8, horiz=TRUE)
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

# deal with missing values:
\end_layout

\begin_layout Plain Layout

D <- D[!is.na (D$Time), ]
\end_layout

\begin_layout Plain Layout

#interpolate if necessary:
\end_layout

\begin_layout Plain Layout

VNS <- zoo::na.approx (as.vector(D$VNS), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

VEW <- zoo::na.approx (as.vector(D$VEW), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

GGVNS <- zoo::na.approx (as.vector(D$GGVNS), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

GGVEW <- zoo::na.approx (as.vector(D$GGVEW), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

# 1013 points (must be odd) to span about 1/5 Schuler osc.
 -- about 16.8 min
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

NAV <- 1013 * Rate
\end_layout

\begin_layout Plain Layout

vndot <- signal::sgolayfilt (VNS-GGVNS, 3, NAV, m=1) * Rate  # m=1 for first
 deriv.
\end_layout

\begin_layout Plain Layout

vedot <- signal::sgolayfilt (VEW-GGVEW, 3, NAV, m=1) * Rate
\end_layout

\begin_layout Plain Layout

deltaPitch <- vndot/Ranadu::Gravity (D$LAT, D$GGALT) ## would be negative
 but
\end_layout

\begin_layout Plain Layout

                                                     ## flight is to south
\end_layout

\begin_layout Plain Layout

deltaRoll <- -vedot/Ranadu::Gravity (D$LAT, D$GGALT) ## negative because
 S-bound
\end_layout

\begin_layout Plain Layout

plotWAC(D$Time, deltaPitch/Cradeg, ylab=expression(paste('error [', degree,
 ']')),
\end_layout

\begin_layout Plain Layout

        ylim=c(-0.02,0.022))
\end_layout

\begin_layout Plain Layout

lineWAC (D$Time, deltaRoll/Cradeg, col="darkgreen")
\end_layout

\begin_layout Plain Layout

legend('top', legend=c(expression(paste(delta, theta)), expression(paste(delta,p
hi))), lwd=2, col=c("blue", "darkgreen"), text.col=c("blue", "darkgreen"),
 cex=0.8, horiz=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An example from a ferry flight of the NSF/NCAR GV project is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:v-errors-straight-leg}
\end_layout

\end_inset

.
 The heading for most of this flight was close to southbound and steady,
 so to a reasonable approximation the errors in pitch and roll will be given
 by the respective derivatives in the error terms 
\begin_inset Formula $\delta v_{n}$
\end_inset

 and 
\begin_inset Formula $\delta v_{e}$
\end_inset

, divided by the acceleration of gravity and converted to units of degrees.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\lang english
The amplitude of the Schuler oscillation is about 0.5 to 0.75 m/s, which would
 indicate that the pitch error is about (0.5--0.75)(0.00124)/9.8
\begin_inset Formula $\simeq0.005^{\circ}$
\end_inset

.
 For this flight, the error in pitch is very small compared to the expected
 uncertainty in angle-of-attack (0.1
\begin_inset Formula $^{\circ}$
\end_inset

).
 A Schuler oscillation in the north component of the aircraft ground-speed
 of 1 m/s indicates that, in the l-frame, the pitch error is <0.01
\begin_inset Formula $^{\circ}$
\end_inset

.
 
\end_layout

\end_inset

The derivatives, estimated using Savitzky-Golay polynomials fitted to the
 difference in ground-speed components as measured by the IRS and a GPS
 receiver, are shown in the bottom panel of Fig._
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:v-errors-straight-leg}
\end_layout

\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Savitzky-Golay polynomials were chosen because they are computationally
 efficient, don't introduce a time shift, and can provide derivatives directly.
\end_layout

\end_inset

 A rather long averaging period of 1013 s, or about 1/5 of a Schuler oscillation
, was used to reduce noise in the result.
\end_layout

\begin_layout Standard
The result is that the magnitude of the pitch error is limited to 
\begin_inset Formula $<0.01^{\circ}$
\end_inset

for most of this flight, except for the final descent, and the roll error
 is limited to less than about 0.015
\begin_inset Formula $^{\circ}$
\end_inset

for the same period.
 This is evidence for low uncertainty in both measurements for this flight,
 well below the specified uncertainty of 0.05
\begin_inset Formula $^{\circ}$
\end_inset

.
 
\end_layout

\begin_layout Subsection
Transformation of attitude angles
\end_layout

\begin_layout Standard
In a reference frame called the 
\begin_inset Formula $l$
\end_inset

-frame or ENU frame, where the coordinate axes are local-east, local-north,
 and upward, the derivation in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Sect2.1"

\end_inset

 showed that the pitch and roll errors are related via (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:full-delta-pitch"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-phi"

\end_inset

) to the time-derivatives of the errors in horizontal velocity.
 Pitch and roll as used in these equations are the respective errors in
 platform alignment
\begin_inset Foot
status open

\begin_layout Plain Layout
The inertial system used is a strap-down system, so there is no actual motion
 of the 
\begin_inset Quotes eld
\end_inset

platform
\begin_inset Quotes erd
\end_inset

.
 Instead, from measured rotations and accelerations, the system calculates
 the expected orientation if there were a true stabilized platform.
 The errors referenced here are those relative to that calculated platform
 orientation.
\end_layout

\end_inset

 in the north-south and east-west directions, so these angles must be transforme
d to account for the orientation of the aircraft when it is not flying straight-
and-level to the north.
 Because transformations for roll and pitch do not change the magnitude
 of the errors in those quantities, only a rotation about the 
\begin_inset Formula $z$
\end_inset

 axis for heading is needed to obtain the error components in the body or
 
\begin_inset Formula $b$
\end_inset

-frame of the aircraft.
 This leads to pitch errors in the body frame of the aircraft that are mixtures
 of pitch and roll errors in the 
\begin_inset Formula $l$
\end_inset

-frame, with the mixture dependent on the heading.
 A positive pitch error for northbound level flight will be a negative pitch
 error for southbound level flight, and for eastbound flight an 
\begin_inset Formula $l$
\end_inset

-frame roll error becomes an 
\begin_inset Formula $a$
\end_inset

-frame pitch error while an 
\begin_inset Formula $l$
\end_inset

-frame pitch error become a negative 
\begin_inset Formula $a$
\end_inset

-frame roll error.
 
\end_layout

\begin_layout Standard
Consider a unit vector representing the orientation errors in pitch and
 roll in the 
\begin_inset Formula $l$
\end_inset

-frame, with east, north, and upward components 
\begin_inset Formula $\mathbf{b^{(l)}=}$
\end_inset

{
\begin_inset Formula $\sin\delta\phi^{(l)},\,-\sin\delta\theta^{(l)},\,\sqrt{1-\sin^{2}\delta\phi^{(l)}-\sin^{2}\delta\theta^{(l)}}$
\end_inset

} or, because the errors are always small, approximately {
\begin_inset Formula $\delta\phi^{(l)},\,-\delta\theta^{(l)},\,1$
\end_inset

}.
 The transformation of these errors from the 
\begin_inset Formula $l$
\end_inset

-frame to the 
\begin_inset Formula $b$
\end_inset

-frame
\begin_inset Foot
status open

\begin_layout Plain Layout
The 
\begin_inset Formula $b$
\end_inset

-frame is relative to aircraft-based coordinates but has 
\begin_inset Formula $\hat{x}$
\end_inset

 starboard, 
\begin_inset Formula $\hat{y}$
\end_inset

 forward, and 
\begin_inset Formula $\hat{z}$
\end_inset

 upward in the aircraft reference frame, so it differs from the 
\begin_inset Formula $a$
\end_inset

-frame by having 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 axes interchanged and 
\begin_inset Formula $z$
\end_inset

 axis reversed in sign.
\end_layout

\end_inset

 requires a rotation by the 
\emph on
negative
\emph default
 of the heading angle 
\begin_inset Formula $\psi$
\end_inset

 in the 
\begin_inset Formula $l$
\end_inset

-frame but does not require further transformation because differences in
 pitch and roll between the 
\begin_inset Formula $l$
\end_inset

 and 
\begin_inset Formula $a$
\end_inset

 reference frames do not affect the estimate of platform mis-alignment and
 how that misalignment is resolved into pitch and roll components.
 Therefore, 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\mathbf{b^{(a)}=}R_{l}^{a}\mathbf{b^{(l)}} & \approx & \left[\begin{array}{ccc}
\cos\psi & -\sin\psi & 0\\
\sin\psi & \cos\psi & 0\\
0 & 0 & 1
\end{array}\right]\begin{bmatrix}\delta\phi^{(l)}\\
-\delta\theta^{(l)}\\
1
\end{bmatrix}\label{eq:b-vector-in-b-frame}\\
 & \simeq & \begin{bmatrix}\cos\psi\delta\phi^{(l)}+\sin\psi\delta\theta^{(l)}\\
\sin\psi\delta\phi^{(l)}-\cos\psi\delta\theta^{(l)}\\
1
\end{bmatrix}
\end{eqnarray}

\end_inset

which leads to 
\begin_inset Formula $\delta\theta^{(a)}$
\end_inset

 and 
\begin_inset Formula $\delta\phi^{(a)}$
\end_inset

, the pitch and roll errors in the 
\begin_inset Formula $b$
\end_inset

-frame or 
\begin_inset Formula $a$
\end_inset

-frame:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{eqnarray}
\delta\theta^{(a)} & \simeq & -b_{2}^{(b)}/b_{3}^{(b)}=-\sin\psi\delta\phi^{(l)}+\cos\psi\delta\theta^{(l)}\label{eq:final-answer}\\
\delta\phi^{(a)} & \approx & b_{1}^{(b)}/b_{3}^{(b)}=\cos\psi\delta\phi^{(l)}+\sin\psi\delta\theta^{(l)}\,\,\,.\nonumber 
\end{eqnarray}

\end_inset

These errors should then be 
\emph on
subtracted
\emph default
 from the angles measured by the INS to obtain corrected values.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Xform-l-from-b-pitch, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

XformLB-old <- function (bvector, .roll, .pitch, .heading, .reverse=FALSE) {
\end_layout

\begin_layout Plain Layout

  Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

  sr <- sin(.roll*Cradeg); cr <- cos(.roll*Cradeg)
\end_layout

\begin_layout Plain Layout

  sp <- sin(.pitch*Cradeg); cp <- cos(.pitch*Cradeg)
\end_layout

\begin_layout Plain Layout

  sh <- sin(.heading*Cradeg); ch <- cos(.heading*Cradeg)
\end_layout

\begin_layout Plain Layout

  if (.reverse) {   # note that entries are in column order; transpose before
 use
\end_layout

\begin_layout Plain Layout

    M <- c(sh*cr+ch*sp*sr, ch*cr-sh*sp*sr, -cp*sr,
\end_layout

\begin_layout Plain Layout

           ch*cp, -sh*cp, sp,
\end_layout

\begin_layout Plain Layout

           -sh*sr+ch*sp*cr, -ch*sr-sh*sp*cr, -cp*cr)
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    M <- c(sh*cp, ch*cr+sh*sp*sr, ch*sr-sh*sp*cr,
\end_layout

\begin_layout Plain Layout

            ch*cp, -sh*cr+ch*sp*sr, -sh*sr-ch*sp*cr,
\end_layout

\begin_layout Plain Layout

            -sp, cp*sr, cp*cr)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  dim (M) <- c(3,3)
\end_layout

\begin_layout Plain Layout

  return (t(M) %*% bvector)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<processing-1, fig.height=3.5, fig.cap="Measured errors in ground-speed components
 for DEEPWAVE research flight 1.
 $V_e^{IRS}$ and $V_n^{IRS}$ are the east and north components of the ground
 speed measured by the inertial system, and $V_e^{GPS}$ and $V_n^{GPS}$
 are the corresponding components measured independently by the GPS receiver.",
 include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- "rf01h"
\end_layout

\begin_layout Plain Layout

Flight <- "rf01"
\end_layout

\begin_layout Plain Layout

# Flight <- "rf15"
\end_layout

\begin_layout Plain Layout

fname <- sprintf ("%s%s/%s%s.nc", DataDirectory (), Project, Project, Flight)
\end_layout

\begin_layout Plain Layout

VarNames <- c("VNS", "VEW","GGVNS", "GGVEW", "GGALT", "LATC", "LONC", "THDG",
 "PITCH", "ROLL")
\end_layout

\begin_layout Plain Layout

SaveRData2 <- sprintf("DataFrames/%s2.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF (fname, standardVariables(VarNames))
\end_layout

\begin_layout Plain Layout

  save(Data, file=SaveRData2)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

Ts <- -120
\end_layout

\begin_layout Plain Layout

Data$VEW <- ShiftInTime (Data$VEW, Rate, Ts)
\end_layout

\begin_layout Plain Layout

Data$VNS <- ShiftInTime (Data$VNS, Rate, Ts)
\end_layout

\begin_layout Plain Layout

Ts <- -60
\end_layout

\begin_layout Plain Layout

Data$THDG <- ShiftInTime (Data$THDG, Rate, Ts)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D <- Data[Data$TASX > 130, ]
\end_layout

\begin_layout Plain Layout

#D <- D[setRange(D$Time, 81500,82500),]
\end_layout

\begin_layout Plain Layout

plotWAC (D$Time, D$GGVEW-D$VEW, ylab="Ve error [m/s]", ylim=c(-5, 8.))
\end_layout

\begin_layout Plain Layout

lineWAC (D$Time, D$GGVNS-D$VNS, col='darkgreen', lwd=1)
\end_layout

\begin_layout Plain Layout

legend ('topleft', legend=c('VEW-GGVEW', 'VNS-GGVNS'), lwd=c(2,1), col=c('blue',
 'darkgreen'), text.col=c('blue', 'darkgreen'), ncol=2)
\end_layout

\begin_layout Plain Layout

figcapP2=c("Top: Errors in pitch ($
\backslash

\backslash
delta
\backslash

\backslash
theta^{(l)}$) and roll ($
\backslash

\backslash
delta
\backslash

\backslash
phi^{(l)}$) determined from the measured errors in ground-speed components
 via (
\backslash

\backslash
ref{eq:final-answer}), as measured in the $l$-frame.
 Measurements are from the DEEPWAVE project, research flight 1.
 Bottom: Errors in pitch ($
\backslash

\backslash
delta
\backslash

\backslash
theta$) and roll ($
\backslash

\backslash
delta
\backslash

\backslash
phi$) determined from the measured errors in ground-speed components, after
 transformation of the errors shown in the previous plot to the reference
 frame that is the body frame of the aircraft.
 Measurements are from the DEEPWAVE project, research flight 1.
 The limits $
\backslash

\backslash
pm$0.02 correspond to roll angle of $
\backslash

\backslash
pm 20^{
\backslash

\backslash
circ}$ after division by 1000.")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Application to a representative research flight
\begin_inset CommandInset label
LatexCommand label
name "sub:Application-to-research"

\end_inset


\end_layout

\begin_layout Standard
The research flights have frequent changes in heading, with associated mixing
 of the roll and pitch errors but also accelerations that affect those errors
 and introduce new errors from heading errors.
 The corrections to pitch therefore appear much less systematic than was
 the case for the ferry flight, and in some cases the corrections are considerab
ly larger.
 An example, DEEPWAVE research flight 1 (June 6 2014), is presented here.
 The DEEPWAVE (Deep Propagating Gravity Wave Experiment over New Zealand)
 field project is described at this web site: http://www.eol.ucar.edu/field_project
s/deepwave.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:processing-2}
\end_layout

\end_inset

 shows the estimated errors in pitch and roll in the 
\begin_inset Formula $l$
\end_inset

-frame for this flight and those errors after transformation to the 
\begin_inset Formula $a$
\end_inset

-frame.
 There are instances in the latter where the pitch error abruptly reverses
 sign; those are cases where the flight direction changes by about 180
\begin_inset Formula $^{\circ}$
\end_inset

.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
There are also some times when there are noise and jumps in the differences.
 These arise in turns and appear to be the result of small timing differences,
 which have not been corrected here because 1-Hz data rates were used while
 the indicated difference was found consistent with about 160
\begin_inset space ~
\end_inset

ms lag in the IRS measurements.
\end_layout

\end_inset

In straight-and-level flight, the needed corrections are about 
\begin_inset Formula $\pm$
\end_inset

0.03
\begin_inset Formula $^{\circ}$
\end_inset

 at some times, and this error can lead (for true airspeed of 220 m/s) to
 an error in vertical wind of about 
\begin_inset Formula $\pm0.1$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m/s.
 A mismatch in timing between measurements from IRS and GPS units will affect
 measurements in turns, and there is some evidence of this in Fig.\SpecialChar \-

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:processing-2}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsection
Discussion
\end_layout

\begin_layout Standard
The magnitude of the correction in the example shown is significant in compariso
n to the total uncertainty in measurements of vertical wind (discussed further
 in the Appendix), so correction for this error should lead to a significant
 reduction in the uncertainty associated with the measured vertical wind.
 There can be various sources for the error in pitch, including initial
 alignment, bias or other errors from the IRS sensors, possible effects
 of horizontal accelerations or turbulence on platform alignment, and others.
 However, the equations (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:final-answer"

\end_inset

) used to detect this error do not depend on the source of the error; any
 error in pitch will introduce an error in horizontal acceleration, and
 that error can be detected by comparison to corresponding measurements
 from the GPS receiver provided that the measurements from the GPS unit
 are accurate and the INS accelerometers themselves introduce little error.
 
\end_layout

\begin_layout Standard
Modern GPS receivers, often incorporating differential-GPS corrections and
 ionospheric corrections, are capable of measuring horizontal motions with
 uncertainties as small as 3
\begin_inset space ~
\end_inset

cm
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 Representative variance spectra for the GPS-measured velocity components
 suggest an onset of noise at around 0.2
\begin_inset space \thinspace{}
\end_inset

Hz with approximate amplitude of 0.1
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

, suggesting an ability to measure accelerations with an uncertainty of
 about 0.02
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

 for measurements spanning 5
\begin_inset space ~
\end_inset

s.
 From (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:full-delta-pitch"

\end_inset

), this suggests an uncertainty in the pitch correction of about 0.002 or
 0.1
\begin_inset Formula $^{\circ}$
\end_inset

 for measurements with this separation.
 It appears from plots like those shown above that the pitch correction
 varies only slowly with time, so this estimate can be improved significantly
 by using longer averaging times.
 For times of 5
\begin_inset space ~
\end_inset

min, for example, the uncertainty in acceleration can be less than 0.0001
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 and the corresponding uncertainty in the pitch correction is less than
 0.002
\begin_inset Formula $^{\circ}$
\end_inset

.
 
\end_layout

\begin_layout Standard
The uncertainty introduced by errors in measured horizontal acceleration
 is more difficult to estimate.
 The errors they introduce in ground-speed components contribute to errors
 in pitch and roll through the strong coupling between ground-speed-component
 errors and attitude-angle errors, so the algorithm proposed here will correct
 for a portion of the past history of contributions via accelerometer errors
 but not the immediate contribution at the observation time.
 Because normal measurements of lateral accelerations are quite small and
 appear unbiased away from turns, it is likely that these errors arise primarily
 during turns and can be diagnosed away from turns.
 One estimate of the magnitude of this contribution can be based on the
 growth of the magnitude of the Schuler oscillation in ground-speed errors,
 which in normal cases is limited to about 0.5
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 per hour of flight or an accumulated acceleration of around 
\begin_inset Formula $10^{-4}$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 As argued in the preceding paragraph, this magnitude of uncertainty in
 acceleration would lead to uncertainty in pitch correction of less than
 0.002
\begin_inset Formula $^{\circ}.$
\end_inset


\end_layout

\begin_layout Standard
At this level, the uncertainty in pitch arising from the measurements of
 horizontal acceleration from either the INS or GPS receiver does not make
 a significant contribution to the uncertainty in measurements of vertical
 wind because other sources dominate, as discussed in the Appendix.
 For straight flight paths, the correction procedure thus can be considered
 to remove the error in pitch.
 In turns, however, the relative timing of the measurements can introduce
 biases that cause errors extending not only during but also for a short
 period before and after the turns, with duration depending on the averaging
 period used.
\end_layout

\begin_layout Standard
For research applications, the roll correction is seldom of much consequence,
 but the pitch correction can either produce significant improvement in
 the calculated vertical wind or, when small, can reduce the uncertainty
 below that based solely on specifications for the measurement from the
 IRS.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout

<<calculate-pitch-correction, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## The correction should be subtracted from PITCH to get PITCHC;
\end_layout

\begin_layout Plain Layout

## it is the error in pitch, so you get the true value by subtraction
\end_layout

\begin_layout Plain Layout

## This calculates corrections for an entire flight in one call.
\end_layout

\begin_layout Plain Layout

## D must be a dataframe containing at least VNS, VEW, GGVNS, GGVEW,
\end_layout

\begin_layout Plain Layout

## LATC, GGALT, THDG, PITCH, ROLL, 
\end_layout

\begin_layout Plain Layout

CorrectPitch <- function (D, .span=1013) {
\end_layout

\begin_layout Plain Layout

  Rate <- 1
\end_layout

\begin_layout Plain Layout

  MaxGap <- 300 * Rate
\end_layout

\begin_layout Plain Layout

  .vns <- zoo::na.approx (as.vector(D$VNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  .vew <- zoo::na.approx (as.vector(D$VEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  .ggvns <- zoo::na.approx (as.vector(D$GGVNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  .ggvew <- zoo::na.approx (as.vector(D$GGVEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  # 1013 points (must be odd) to span about 1/5 Schuler osc.
 -- about 16.8 min
\end_layout

\begin_layout Plain Layout

  NAV <- .span * Rate
\end_layout

\begin_layout Plain Layout

  vndot <- signal::sgolayfilt (.vns-.ggvns, 3, NAV, m=1) * Rate  # m=1 for
 first deriv.
\end_layout

\begin_layout Plain Layout

  vedot <- signal::sgolayfilt (.vew-.ggvew, 3, NAV, m=1) * Rate
\end_layout

\begin_layout Plain Layout

  deltaPitchL <- -vndot/Ranadu::Gravity (D$LATC, D$GGALT)
\end_layout

\begin_layout Plain Layout

  deltaRollL  <- vedot/Ranadu::Gravity (D$LATC, D$GGALT)
\end_layout

\begin_layout Plain Layout

  .hdg <- D$THDG*Cradeg
\end_layout

\begin_layout Plain Layout

  deltaPitch <- (sin(.hdg)*deltaRollL + cos(.hdg)*deltaPitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

  deltaRoll <- (cos(.hdg)*deltaRollL - sin(.hdg)*deltaPitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

  C <- c(deltaPitch, deltaRoll)
\end_layout

\begin_layout Plain Layout

  dim(C) <- c(nrow(D), 2)
\end_layout

\begin_layout Plain Layout

  return (C)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<processing-2, fig.height=6.5, fig.cap=figcapP2, include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol = 1), widths = 1, heights = c(5,6))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

# deal with missing values:
\end_layout

\begin_layout Plain Layout

D <- D[!is.na (D$Time), ]
\end_layout

\begin_layout Plain Layout

#interpolate if necessary:
\end_layout

\begin_layout Plain Layout

VNS <- zoo::na.approx (as.vector(D$VNS), maxgap=100*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

VEW <- zoo::na.approx (as.vector(D$VEW), maxgap=100*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

GGVNS <- zoo::na.approx (as.vector(D$GGVNS), maxgap=100*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

GGVEW <- zoo::na.approx (as.vector(D$GGVEW), maxgap=100*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

# 1013 points (must be odd) to span about 1/5 Schuler osc.
 -- about 16.8 min
\end_layout

\begin_layout Plain Layout

NAV <- 1013*Rate
\end_layout

\begin_layout Plain Layout

vndot <- signal::sgolayfilt (VNS-GGVNS, 3, NAV, m=1) * Rate  # m=1 for first
 deriv.
\end_layout

\begin_layout Plain Layout

vedot <- signal::sgolayfilt (VEW-GGVEW, 3, NAV, m=1) * Rate
\end_layout

\begin_layout Plain Layout

deltaPitchL <- -vndot/Ranadu::Gravity (D$LAT, D$GGALT)
\end_layout

\begin_layout Plain Layout

deltaRollL <- vedot/Ranadu::Gravity (D$LAT, D$GGALT)
\end_layout

\begin_layout Plain Layout

HDG <- D$THDG*Cradeg
\end_layout

\begin_layout Plain Layout

D$deltaPitch <- (sin(HDG)*deltaRollL + cos(HDG)*deltaPitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

D$deltaRoll <- (cos(HDG)*deltaRollL - sin(HDG)*deltaPitchL)/Cradeg
\end_layout

\begin_layout Plain Layout

# DeltaPitch2 <- CorrectPitch(D)
\end_layout

\begin_layout Plain Layout

D$dRL <- deltaRollL/Cradeg
\end_layout

\begin_layout Plain Layout

D$dPL <- deltaPitchL/Cradeg
\end_layout

\begin_layout Plain Layout

plotWAC (D[, c("Time", "dPL", "dRL")], ylab=expression (paste (delta, theta^(l),
 ' or ', delta, phi^(l), ' [', degree, ']')), lwd=c(2.5, 2, 1.5),  lty=c(1,1,3),
 ylim=c(-0.04,0.05), legend.position=NA)
\end_layout

\begin_layout Plain Layout

# lineWAC(D$Time, D$THDG/10000, col='red')
\end_layout

\begin_layout Plain Layout

legend('top', legend=c(expression (paste (delta, theta^(l))), expression
 (paste (delta, phi^(l)))), lwd=c(2.5,2), lty=c(1,1), col=c("blue", "darkgreen"),
 text.col=c("blue", "darkgreen"), cex=0.8, bg='lightyellow', horiz=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

# D$deltaRoll <- SmoothInterp(D$deltaRoll, .Length=121)
\end_layout

\begin_layout Plain Layout

# D$deltaPitch <- SmoothInterp(D$deltaPitch, .Length=121)
\end_layout

\begin_layout Plain Layout

plotWAC (D[, c("Time", "deltaPitch", "deltaRoll")], ylab=expression (paste
 (delta, theta, ' or ', delta, phi, ' [', degree, ']')), lwd=c(2.5, 2, 1.5),
  lty=c(1,1,3), ylim=c(-0.04,0.05), legend.position=NA)
\end_layout

\begin_layout Plain Layout

#Z <- lineWAC (D$Time, deltaRoll2, col='darkgreen')
\end_layout

\begin_layout Plain Layout

#Z <- lineWAC (D$Time, deltaPitch, col='darkorange', lty=2, lwd=1.2)
\end_layout

\begin_layout Plain Layout

#Z <- lineWAC (D$Time, deltaRoll, col='red', lty=2, lwd=1.2)
\end_layout

\begin_layout Plain Layout

Z <- lineWAC (D$Time, D$ROLL/1000, col='red', lwd=1.5, lty=1)
\end_layout

\begin_layout Plain Layout

legend('top', legend=c(expression (paste (delta, theta)), expression (paste
 (delta, phi)), "ROLL/1000"), lwd=c(2.5,2,1.5), lty=c(1,1,1), col=c("blue",
 "darkgreen", "red"), text.col=c("blue", "darkgreen", "red"), cex=0.8, bg='lightye
llow', horiz=TRUE)
\end_layout

\begin_layout Plain Layout

Valid <- (D$TASX > 130)
\end_layout

\begin_layout Plain Layout

Valid[abs(D$ROLL) > 5] <- FALSE
\end_layout

\begin_layout Plain Layout

## hist (CorrectPitch(D)[Valid], xlim=c(-0.05, 0.05))
\end_layout

\begin_layout Plain Layout

## mean is very close to zero
\end_layout

\begin_layout Plain Layout

## mean (CorrectPitch(D)[Valid], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

SDofCorrection = sd (CorrectPitch(D)[Valid], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## check how this would change with an accelerometer bias of 1%
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Some details regarding smoothing
\end_layout

\begin_layout Standard
While (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:final-answer"

\end_inset

) provides a correction applicable to each measurement, some smoothing is
 desirable not only to decrease the uncertainty in the correction but also
 to avoid introducing high-frequency noise into signals that might distort
 the variance spectrum or affect other uses where noise is undesirable.
 A specific choice was made for the examples shown, but other choices might
 perform better and may benefit from tailoring to the flight patterns.
 The velocity errors usually vary smoothly and approximately sinusoidally,
 as shown in Figs.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:v-errors-straight-leg}
\end_layout

\end_inset

, except for occasional noise associated with turns or turbulence.
 Smoothing the time series of these error terms can be combined with finding
 the derivatives required in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:full-delta-pitch"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-phi"

\end_inset

) if Savitzky-Golay polynomials are fitted to the time series.
 The specific choice made here is to use third-order polynomials covering
 1013 points or, for 1-Hz measurements, about 1/5 of a Schuler oscillation.
 In the 
\begin_inset Formula $l$
\end_inset

-frame where these errors are measured they are usually quite regular over
 several oscillations so this provides a compromise between good smoothing
 and response to changes in the amplitude and phase of the oscillations.
 This usually produces smooth corrections except near turns, where some
 more abrupt changes occur.
 Most research measurements of wind are made during straight flight legs,
 so these fluctuations near turns are not a serious impediment in the normal
 case.
 They appear to arise from timing differences among the different measurements
 being used.
 For example, if the measurement of heading lags behind the derivatives,
 the rotation of 
\begin_inset Formula $l$
\end_inset

-frame errors to the 
\begin_inset Formula $a$
\end_inset

-frame will lead to different errors in right vs.
\begin_inset space ~
\end_inset

left turns, leading to jumps in the correction terms like those evident
 at, e.g., about 12:00 UTC in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:processing-2}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The final step in the application of the correction algorithm for pitch
 is to subtract the term given by (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:final-answer"

\end_inset

) from the measured pitch or roll and use the result when the Earth-relative
 wind is calculated.
 
\end_layout

\begin_layout Section
Correcting the measurement of heading
\begin_inset CommandInset label
LatexCommand label
name "sec:heading-correction"

\end_inset


\end_layout

\begin_layout Subsection
The basis for the correction
\end_layout

\begin_layout Standard
A procedure related to that used for pitch is developed here for estimating
 the error in heading.
 The basis for the correction is that an error in heading results in an
 error in how the measured body-relative components of the acceleration
 are transformed to the ENU or 
\emph on
l
\emph default
-frame (in the terminology of the previous discussion of the correction
 for pitch).
 These errors can be detected by comparing the actual acceleration of the
 aircraft (determined from derivatives of the GPS-measured ground-speed
 components, as in the preceding section) to the measurements of acceleration
 after transformation to the 
\emph on
l
\emph default
-frame.
\begin_inset Foot
status open

\begin_layout Plain Layout
Some additional considerations arising from rotation of the earth and rotation
 of the 
\begin_inset Formula $l$
\end_inset

-frame in an inertial frame are discussed later; cf.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rotation-correction"

\end_inset

).
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
The accelerations measured by a strap-down inertial system like the Honeywell
 systems on the NCAR/NSF GV are the accelerations in the reference frame
 of the aircraft, here called the 
\begin_inset Formula $a$
\end_inset

-frame.
 To transform these to the 
\emph on
l
\emph default
-frame, the transformation by conventional definition of the attitude angles
 involves a rotation about the roll axis to level the wings, a rotation
 about the pitch axis to level the longitudinal axis of the aircraft, and
 a rotation about the vertical axis as required to point the aircraft to
 the north.
 However, if there is an error in the heading (
\begin_inset Formula $\delta\psi$
\end_inset

) the last rotation will give final components 
\begin_inset Formula $a_{x,y,z}^{(l)}$
\end_inset

 that have respective errors of 
\begin_inset Formula $\delta a_{x}^{(l)}=a_{x}^{(l)}(1-\cos\delta\psi)-a_{y}^{(l)}\sin\delta\psi$
\end_inset

, 
\begin_inset Formula $\delta a_{y}^{(l)}=a_{y}^{(l)}(1-\cos\delta\psi)+a_{x}^{(l)}\sin\delta\psi$
\end_inset

, and 
\begin_inset Formula $\delta a_{z}^{(l)}=0$
\end_inset

 or, for small angles,
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{align}
\left[\begin{array}{c}
\delta a_{x}^{(l)}\\
\delta a_{y}^{(l)}\\
\delta a_{z}^{(l)}
\end{array}\right] & =\left[\begin{array}{ccc}
0 & -\delta\psi & 0\\
\delta\psi & 0 & 0\\
0 & 0 & 0
\end{array}\right]\left[\begin{array}{c}
a_{x}^{(l)}\\
a_{y}^{(l)}\\
a_{z}^{(l)}
\end{array}\right]\label{eq:heading-error-equation}\\
\delta a_{x}^{(l)} & =-a_{y}^{(l)}\delta\psi\label{eq:ax-error}\\
\delta a_{y}^{(l)} & =a_{x}^{(l)}\delta\psi\label{eq:ay-error}\\
\delta\psi & =\frac{a_{x}^{(l)}\delta a_{y}^{(l)}-a_{y}^{(l)}\delta a_{x}^{(l)}}{(a_{x}^{(l)})^{2}+(a_{y}^{(l)})^{2}}\label{eq:estimator-equation}
\end{align}

\end_inset

The last equation is obtained
\begin_inset Foot
status open

\begin_layout Plain Layout
If the error measure to be minimized is 
\begin_inset Formula $\chi^{2}=(\delta a_{x}+a_{y}\delta\psi)^{2}+(\delta a_{y}-a_{x}\delta\psi)^{2}$
\end_inset

, differentiating 
\begin_inset Formula $\chi^{2}$
\end_inset

 with respect to 
\begin_inset Formula $\delta\psi$
\end_inset

 and setting the result equal to zero gives (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

).
\end_layout

\end_inset

 by minimizing the errors between the values of 
\begin_inset Formula $\delta a_{i}^{(l)}$
\end_inset

 given by (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ax-error"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ay-error"

\end_inset

) and the measured error given by 
\begin_inset Formula $(a_{i}^{*}-a_{i}^{(l)})$
\end_inset

.
 This then gives an estimate of the rotation 
\begin_inset Formula $-\delta\psi$
\end_inset

 that gives the best match between the measured accelerations and those
 determined from the derivatives of the GPS-provided ground-speed components.
 The resulting value of 
\begin_inset Formula $\delta\psi$
\end_inset

 from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

) is then an estimate of the error in heading.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
An alternate and simpler (but equivalent) approach is to transform the component
s of acceleration measured in the 
\begin_inset Formula $b$
\end_inset

-frame to the 
\begin_inset Formula $l$
\end_inset

-frame, use them to determine the Earth-relative direction of the acceleration
 vector 
\begin_inset Formula $\alpha^{(l)}$
\end_inset

 in the 
\begin_inset Formula $l$
\end_inset

-frame, and find the difference between that result and the direction found
 for Earth-based acceleration 
\begin_inset Formula $\alpha^{*}$
\end_inset

 obtained by differentiating the measurements of velocity components by
 a GPS receiver.
 In this case,
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\alpha^{*}=\arctan\frac{\dot{v}_{x}^{(l)}}{\dot{v}_{y}^{(l)}}\label{eq:alpha-GPS}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\alpha^{(l)}=\arctan\frac{a_{x}^{(l)}}{a_{y}^{(l)}}\label{eq:alpha-l}
\end{equation}

\end_inset

where 
\begin_inset Formula $\dot{v}_{1}$
\end_inset

 and 
\begin_inset Formula $\dot{v}_{2}$
\end_inset

 refer to the accelerations determined by differentiating the measurements
 of ground-speed components 
\begin_inset Formula $v_{1}$
\end_inset

 and 
\begin_inset Formula $v_{2}$
\end_inset

, the eastward and northward components of the ground speed measured by
 a GPS receiver.
 If there are no other sources of error, the difference between these two
 directions will arise from the heading error that causes the components
 {
\begin_inset Formula $a_{1}^{(l)},\,a_{2}^{(l)},\,a_{3}^{(l)}$
\end_inset

} to point in an incorrect direction in the 
\begin_inset Formula $l$
\end_inset

-frame.
 Therefore, an estimate of the heading error can be obtained from
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\delta\psi=\alpha^{*}-\alpha^{(l)}\,\,\,.\label{eq:error-estimate-2}
\end{equation}

\end_inset

Other sources of error can arise from biases or other errors in the measurements
 of acceleration, from timing errors (e.g., displacing the measurements of
 heading and so introducing errors in turns), or from the measurements by
 GPS of the velocity components relative to the Earth.
 Any of those possibilities can compromise the results that follow, so these
 error sources will need further discussion later in this note.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To use (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

), the acceleration vector 
\begin_inset Formula $\mathbf{a^{*}}$
\end_inset

 must be determined by differentiation of the GPS-measured velocity components.
 As in the pitch-correction algorithm, the choice made here is to estimate
 the derivatives using Savitzky-Golay polynomials, but now with a 31
\begin_inset space \thinspace{}
\end_inset

s span to avoid excessive distortion in 3-min turns.
 However, this choice affects the uncertainty of the estimate, as follows.
 It was previously estimated that the uncertainty in a measurement of accelerati
on from GPS is at least 0.01
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

/
\begin_inset Formula $\tau$
\end_inset

 where 
\begin_inset Formula $\tau$
\end_inset

 is the time over which the average is calculated.
 For 31-s polynomial fits, the effective averaging time is about 20
\begin_inset space \thinspace{}
\end_inset

s, leading to a minimum uncertainty of about 0.0005
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 Equation
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

) indicates that, for an uncertainty in the heading correction of 0.1
\begin_inset Formula $^{\circ}$
\end_inset

 or about 0.002
\begin_inset space ~
\end_inset

radians, the total horizontal acceleration should then be at least 0.0005/0.002=0.2
5
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
\end_layout

\begin_layout Standard
Typical horizontal accelerations in turns exceed 4
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

 but horizontal accelerations exceeding 1
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

 are seldom encountered outside of turns, so the algorithm developed here
 only provides a valid correction if there are regular turns during the
 flight.
 In the following, heading corrections will be calculated only for periods
 when the horizontal acceleration exceeds 1
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

 to avoid excessive noise and uncertainty.
 It is significant, though, that for a flight that transits in a straight
 line from start to finish, attempts to use these estimates are unlikely
 to be useful.
 Fortunately, in most research flights there are many turns, e.g., as the
 aircraft flies back and forth over a mountain range or flies fixed raster
 patterns for mapping.
 Each turn can provide significant horizontal accelerations that give estimates
 of the heading error, but these estimates are only sporadic and must be
 linked by an extrapolation procedure to obtain valid corrections spanning
 periods without significant acceleration.
 The heading correction therefore has a higher uncertainty than the pitch
 correction and, unlike the pitch correction, depends on significant horizontal
 accelerations for its operation.
 In addition, the heading error is not coupled to other errors in ways that
 limit its growth, so implementing some correction procedure is important
 not only to provide corrections but also to determine the estimated magnitude
 of the uncorrected error.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The components of the accelerations of the aircraft in an Earth-relative
 coordinate system like the 
\begin_inset Formula $l$
\end_inset

-frame can be determined solely from measurements provided by a GPS and
 so are independent of the IRS.
 They are determined from
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{equation}
\end_layout

\begin_layout Plain Layout


\backslash
left[
\backslash
begin{array}{c}
\end_layout

\begin_layout Plain Layout

a_{x}^{*}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

a_{y}^{*}
\end_layout

\begin_layout Plain Layout


\backslash
end{array}
\backslash
right]=
\backslash
left[
\backslash
begin{array}{c}
\end_layout

\begin_layout Plain Layout


\backslash
frac{dv_{x}}{dt}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
frac{dv_{y}}{dt}
\end_layout

\begin_layout Plain Layout


\backslash
end{array}
\backslash
right]=
\backslash
left[
\backslash
begin{array}{c}
\end_layout

\begin_layout Plain Layout

d(GGVEW)/dt
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

d(GGVNS)/dt
\end_layout

\begin_layout Plain Layout


\backslash
end{array}
\backslash
right]
\backslash
 
\backslash
 
\backslash
 .
\backslash
label{eq:acceleration-from-GPS}
\end_layout

\begin_layout Plain Layout


\backslash
end{equation}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The transformation from 
\begin_inset Formula $a$
\end_inset

-frame to 
\begin_inset Formula $l$
\end_inset

-frame
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
In NCAR/EOL/RAF data archives, the appropriate body-relative accelerations
 are represented by the netCDF variables BLONGA, BLATA, BNORMA for respectively
 the 
\begin_inset Formula $x$
\end_inset

, 
\begin_inset Formula $y$
\end_inset

, and 
\begin_inset Formula $z$
\end_inset

 components (in the aircraft coordinate system with 
\begin_inset Formula $x$
\end_inset

 forward, 
\begin_inset Formula $y$
\end_inset

 starboard, and 
\begin_inset Formula $z$
\end_inset

 downward), except that BNORMA represents the 
\begin_inset Formula $z$
\end_inset

-upward component and is adjusted by subtraction of the acceleration of
 gravity.
\end_layout

\end_inset

Measurements of body accelerations are provided by most inertial systems
 used on research aircraft, so the procedure developed here is not unique
 to the NCAR aircraft.
 The specific application, however, will use measurements from the NSF/NCAR
 GV research aircraft.
 These measured body accelerations will be represented by (
\begin_inset Formula $a_{1}^{(a)},\,a_{2}^{(a)},\,a_{3}^{(a)}$
\end_inset

), respectively, with 
\begin_inset Formula $a_{3}^{(a)}$
\end_inset

 representing the difference between the downward acceleration and the accelerat
ion of gravity.
 Then, with {
\begin_inset Formula $\phi,\,\theta,\,\psi$
\end_inset

} representing {roll, pitch, heading}, the transformation from the 
\begin_inset Formula $a$
\end_inset

-frame to the 
\emph on
l
\emph default
-frame is that given in standard sources include 
\begin_inset CommandInset citation
LatexCommand citet
key "Bulletin23"

\end_inset

 or 
\begin_inset CommandInset citation
LatexCommand citet
key "noureldin2013fundamentals"

\end_inset

, Eq.
\begin_inset space ~
\end_inset

2-82.
\begin_inset Foot
status open

\begin_layout Plain Layout
There is an error in Eq.
\begin_inset space ~
\end_inset

2.6 of Bulletin 23, where in matrix element (1,3) the first term should be
 
\begin_inset Formula $\sin\psi\sin\phi,$
\end_inset

not 
\begin_inset Formula $\sin\psi\sin\theta$
\end_inset

.
 Standard NCAR/RAF processing uses the correct transformation.
 The transformation given by Noureldin et al.
\begin_inset space ~
\end_inset

is given in terms of the yaw angle, which is the negative of the heading
 angle.
 Also, to use either the transformation in Bulletin 23 or that from Noureldin
 et al., which relates the 
\begin_inset Formula $l$
\end_inset

-frame to the 
\begin_inset Formula $b$
\end_inset

-frame, further transformation is needed to relate the 
\begin_inset Formula $b$
\end_inset

-frame to the 
\begin_inset Formula $a$
\end_inset

-frame.
 The specific transformation used here is included in the Workflow document
 contained in the supplementary material for this paper.
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Formula 
\[
R_{a}^{l}=\begin{bmatrix}\sin\psi\cos\theta & \sin\psi\sin\theta\sin\phi+\cos\psi\cos\phi & \sin\psi\sin\theta\cos\phi-\cos\psi\sin\phi\\
\cos\psi\cos\theta & \cos\psi\sin\theta\sin\phi-\sin\psi\cos\phi & \cos\psi\sin\theta\cos\phi+\sin\psi\sin\phi\\
\sin\theta & -\cos\theta\sin\phi & -\cos\theta\cos\phi
\end{bmatrix}
\]

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
by the rotation matix
\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset Formula 
\begin{equation}
R_{b}^{l}=\begin{bmatrix}\sin\psi\cos\theta & \sin\psi\sin\theta\sin\phi+\cos\psi\cos\phi & -\sin\psi\sin\theta\cos\phi+\cos\psi\sin\phi\\
\cos\psi\cos\theta & \cos\psi\sin\theta\sin\phi-\sin\psi\cos\phi & -\cos\psi\sin\theta\cos\phi-\sin\psi\sin\phi\\
-\sin\theta & \cos\theta\sin\phi & \cos\theta\cos\phi
\end{bmatrix}\label{eq:transform-b-to-l}
\end{equation}

\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
so 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\mathbf{a^{(l)}}=R_{b}^{l}\mathbf{a^{(b)}}\label{eq:matrix-multiplication-eq}
\end{equation}

\end_inset


\end_layout

\end_inset

 This transformation then gives the accelerations in the local reference
 frame with 
\begin_inset Formula $x$
\end_inset

-axis east, 
\begin_inset Formula $y$
\end_inset

-axis north, and 
\begin_inset Formula $z$
\end_inset

-axis upward.
 It incorporates the change in axis definitions as well as the required
 signs of the rotations (i.e., rotation by 
\begin_inset Formula $-\phi,$
\end_inset

 then by 
\begin_inset Formula $-\theta,$
\end_inset

 then by 
\begin_inset Formula $+\psi$
\end_inset

).
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
signs of roll and pitch are reversed but heading is kept unchanged
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reinitialization,echo=FALSE,include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- "rf15" 				
\end_layout

\begin_layout Plain Layout

Project = "DEEPWAVE"			 
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%sZPC.nc", Directory,Project,Project,Flight)
\end_layout

\begin_layout Plain Layout

VarNames <- c("BLATA", "BLONGA", "BNORMA",
\end_layout

\begin_layout Plain Layout

              "VNS", "VEW", "VSPD", "GGVNS", "GGVEW", 
\end_layout

\begin_layout Plain Layout

              "GGVSPD", "LAT", "LON", "ALT", "THDG", "PITCH", "ROLL") 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SaveRData3 <- sprintf("DataFrames/%s3.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF (fname, standardVariables(VarNames))	
\end_layout

\begin_layout Plain Layout

  save(Data, file=SaveRData3)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (SaveRData3)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Cradeg <- pi / 180
\end_layout

\begin_layout Plain Layout

s <- -60
\end_layout

\begin_layout Plain Layout

Data$VEW <- ShiftInTime (Data$VEW, 1, s)
\end_layout

\begin_layout Plain Layout

Data$VNS <- ShiftInTime (Data$VNS, 1, s)
\end_layout

\begin_layout Plain Layout

Data$THDG <- ShiftInTime (Data$THDG, 1, s)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<sg-poly-smoothing, include=FALSE, fig.lp="fig:", fig.cap=c("Ground-speed
 components measured using GPS.", "Estimated components of horizontal acceleratio
n for DEEPWAVE flight rf15, obtained via differentiation of the GPS-measured
 variables GGVEW and GGVNS")>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# deal with missing values:
\end_layout

\begin_layout Plain Layout

D <- Data[!is.na (Data$Time), ]
\end_layout

\begin_layout Plain Layout

#interpolate if necessary:
\end_layout

\begin_layout Plain Layout

D$GGVNS <- zoo::na.approx (as.vector(D$GGVNS), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

D$GGVEW <- zoo::na.approx (as.vector(D$GGVEW), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

D$vndot <- signal::sgolayfilt (D$GGVNS, 3, 21, m=1)  # m=1 for first deriv.
\end_layout

\begin_layout Plain Layout

D$vedot <- signal::sgolayfilt (D$GGVEW, 3, 21, m=1)
\end_layout

\begin_layout Plain Layout

D$vzdot <- signal::sgolayfilt (D$GGVSPD, 3, 7, m=1)
\end_layout

\begin_layout Plain Layout

plotWAC(D[, c("Time", "GGVNS", "GGVEW")])
\end_layout

\begin_layout Plain Layout

plotWAC(D[, c("Time", "vndot", "vedot", "vzdot")])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout

<<Xform, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Xform <- function (data) { # data must contain ROLL, PITCH, HEADING, 
\end_layout

\begin_layout Plain Layout

                           # BLATA, BLONGA, BNORMA
\end_layout

\begin_layout Plain Layout

  Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

  if ("PITCHC" %in% names(data)) {data$PITCH <- data$PITCHC}
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ## note minus signs in the next line
\end_layout

\begin_layout Plain Layout

  PITCH <- -data$PITCH * Cradeg; ROLL <- -data$ROLL * Cradeg
\end_layout

\begin_layout Plain Layout

  THDG <- data$THDG * Cradeg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  cosphi <- cos (ROLL)
\end_layout

\begin_layout Plain Layout

  sinphi <- sin (ROLL)
\end_layout

\begin_layout Plain Layout

  costheta <- cos (PITCH)
\end_layout

\begin_layout Plain Layout

  sintheta <- sin (PITCH)
\end_layout

\begin_layout Plain Layout

  cospsi <- cos (THDG)
\end_layout

\begin_layout Plain Layout

  sinpsi <- sin (THDG)
\end_layout

\begin_layout Plain Layout

  G <- Gravity (data$LATC, data$GGALT)
\end_layout

\begin_layout Plain Layout

  d <- data.frame("X" = data$BLONGA)
\end_layout

\begin_layout Plain Layout

  d$Y <- data$BLATA
\end_layout

\begin_layout Plain Layout

  d$Z <- data$BNORMA + G    ## need to add G for transform; 
\end_layout

\begin_layout Plain Layout

                            ## it was removed from sensed accel.
\end_layout

\begin_layout Plain Layout

  A <- as.matrix(d)
\end_layout

\begin_layout Plain Layout

  DL <- nrow(data)
\end_layout

\begin_layout Plain Layout

  One <- rep (1, DL)
\end_layout

\begin_layout Plain Layout

  ZZ <- rep (0, DL)
\end_layout

\begin_layout Plain Layout

  T1 <- aperm(array (c(One,ZZ,ZZ,ZZ,cosphi,-sinphi,ZZ,sinphi,cosphi), 
\end_layout

\begin_layout Plain Layout

                     dim=c(DL,3,3)))
\end_layout

\begin_layout Plain Layout

  T2 <- aperm(array (c (costheta,ZZ,sintheta,ZZ,One,ZZ,-sintheta,ZZ,costheta),
 
\end_layout

\begin_layout Plain Layout

                     dim=c(DL,3,3)))
\end_layout

\begin_layout Plain Layout

  T3 <- aperm(array (c (cospsi,-sinpsi,ZZ,sinpsi,cospsi,ZZ,ZZ,ZZ,One), 
\end_layout

\begin_layout Plain Layout

                     dim=c(DL,3,3)))
\end_layout

\begin_layout Plain Layout

  AX <- vector ("numeric", DL)
\end_layout

\begin_layout Plain Layout

  AY <- vector ("numeric", DL)
\end_layout

\begin_layout Plain Layout

  AZ <- vector ("numeric", DL)
\end_layout

\begin_layout Plain Layout

  X <- zoo::na.approx (as.vector(d$X), maxgap=1000, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  Y <- zoo::na.approx (as.vector(d$Y), maxgap=1000, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  Z <- zoo::na.approx (as.vector(d$Z), maxgap=1000, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  X[is.na(X)] <- 0
\end_layout

\begin_layout Plain Layout

  Y[is.na(Y)] <- 0
\end_layout

\begin_layout Plain Layout

  Z[is.na(X)] <- 0
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

  for (i in 1:DL) {
\end_layout

\begin_layout Plain Layout

    Y1 <- T1[,,i] %*% matrix (A[i,], 3, 1)
\end_layout

\begin_layout Plain Layout

    Y2 <- T2[,,i] %*% Y1
\end_layout

\begin_layout Plain Layout

    Y3 <- T3[,,i] %*% Y2
\end_layout

\begin_layout Plain Layout

    AX[i] <- Y3[1]; AY[i] <- Y3[2]; AZ[i] <- Y3[3]
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  AZ <- AZ - G
\end_layout

\begin_layout Plain Layout

  return (data.frame(AX=AX, AY=AY, AZ=AZ))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<get-b-vector-and-transform, include=TRUE, fig.height=4, fig.cap=c("Accelerations
 ($a_x$, $a_y$, $a_z$) measured by an INS during a circle maneuver, 3:40:00--3:5
5:00 UTC on 3 July 2014, DEEPWAVE flight 15.
 Also shown as dotted lines are the accelerations deduced from differentiating
 the corresponding GPS-measured ground-speed components ($v_n$ and $v_e$).")>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## these captions are just saved here; they apply to plots now suppressed
\end_layout

\begin_layout Plain Layout

FC1a <- "Measured accelerations translated to the l-frame (x east, y north,
 z up) for DEEPWAVE flight 15, 3 July 2014."
\end_layout

\begin_layout Plain Layout

FC1c <- "As for the preceding figure but for a pitch maneuver, 4:25:00--4:30:00
 UTC."
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

RotationCorrection <- function (.data=Data, .V) {
\end_layout

\begin_layout Plain Layout

  Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

  omegaE <- StandardConstant ('Omega')
\end_layout

\begin_layout Plain Layout

  Re <- StandardConstant ('Re')
\end_layout

\begin_layout Plain Layout

  DL <- nrow (.data)
\end_layout

\begin_layout Plain Layout

  C <- vector ('numeric', 3*DL); dim(C) <- c(DL,3)
\end_layout

\begin_layout Plain Layout

  lat <- .data$LATC * Cradeg
\end_layout

\begin_layout Plain Layout

  sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
\end_layout

\begin_layout Plain Layout

  M12 <- -2*omegaE*sinLat-.V[,1]*tanLat/Re
\end_layout

\begin_layout Plain Layout

  M13 <- 2*omegaE*cosLat+.V[,1]/Re
\end_layout

\begin_layout Plain Layout

  M21 <- 2*omegaE*sinLat+.V[,1]*tanLat/Re
\end_layout

\begin_layout Plain Layout

  M23 <- .V[,2]/Re
\end_layout

\begin_layout Plain Layout

  M31 <- -2*omegaE*cosLat-.V[,1]/Re
\end_layout

\begin_layout Plain Layout

  M32 <- -.V[,2]/Re
\end_layout

\begin_layout Plain Layout

  C[,1] <- M12*.V[,2]+M13*.V[,3]
\end_layout

\begin_layout Plain Layout

  C[,2] <- M21*.V[,1]+M23*.V[,3]
\end_layout

\begin_layout Plain Layout

  C[,3] <- M31*.V[,1]+M32*.V[,2]
\end_layout

\begin_layout Plain Layout

  return (C)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

layout(matrix(1:1, ncol = 1), widths = 1, heights = c(5))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

G <- Gravity (D$LATC, D$GGALT)
\end_layout

\begin_layout Plain Layout

AV <- matrix(c(D$BLONGA, D$BLATA, D$BNORMA+G), ncol=3) #aircraft-frame
\end_layout

\begin_layout Plain Layout

LV <- XformLA (D, AV)                                  #l-frame
\end_layout

\begin_layout Plain Layout

## now corrected for angular effects
\end_layout

\begin_layout Plain Layout

## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

LV <- LV - RotationCorrection (D, LV)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D$LACCX <- LV[, 1]
\end_layout

\begin_layout Plain Layout

D$LACCY <- LV[, 2]
\end_layout

\begin_layout Plain Layout

D$LACCZ <- LV[, 3] + G
\end_layout

\begin_layout Plain Layout

D$LACCX <- signal::sgolayfilt (D$LACCX, 3, 21, m=0)
\end_layout

\begin_layout Plain Layout

D$LACCY <- signal::sgolayfilt (D$LACCY, 3, 21, m=0)
\end_layout

\begin_layout Plain Layout

D$LACCZ <- signal::sgolayfilt (D$LACCZ, 3, 7, m=0)
\end_layout

\begin_layout Plain Layout

# plotWAC(D[, c("Time", "LACCX", "LACCY", "LACCZ")], ylab="acceleration
 [m/s^2]")
\end_layout

\begin_layout Plain Layout

V <- c("Time", "LACCX", "LACCY", "LACCZ", "vedot", "vndot")
\end_layout

\begin_layout Plain Layout

r <- setRange(D$Time, 33500,35500)
\end_layout

\begin_layout Plain Layout

plotWAC(D[r,V], lw=c(3,3,3,5,5), lty=c(1,1,1,3,3), legend.position=NA)
\end_layout

\begin_layout Plain Layout

legend('bottomleft', legend=c(expression(a[x]), expression(a[y]), expression(a[z
]),
\end_layout

\begin_layout Plain Layout

       expression(dv[e]/dt), expression(dv[n]/dt)), 
\end_layout

\begin_layout Plain Layout

       col=c('blue', 'darkgreen', 'red', 'cyan3', 'darkorange'),
\end_layout

\begin_layout Plain Layout

       text.col=c('blue', 'darkgreen', 'red', 'cyan3', 'darkorange'),
\end_layout

\begin_layout Plain Layout

       lwd=c(3,3,3,5,5), lty=c(1,1,1,3,3), bg='lightyellow')
\end_layout

\begin_layout Plain Layout

# r <- setRange(D$Time, 42500, 42830)
\end_layout

\begin_layout Plain Layout

# V <- c(V, "vzdot")
\end_layout

\begin_layout Plain Layout

# plotWAC(D[r,V], lw=c(3,3,3,5,5,5), lty=c(1,1,1,3,3,2))
\end_layout

\begin_layout Plain Layout

# lineWAC(D$Time[r], D$vzdot[r], col='green', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To demonstrate that the accelerations obtained in this way are good matches
 to the accelerations determined by differentiation of GPS-determined velocities
 and to check the transformation matrix, an example of the two components
 of acceleration as determined in these two ways is shown in Fig.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:get-b-vector-and-transform}
\end_layout

\end_inset

.
 This flight segment is a circle maneuver in which a full circle is flown
 twice drifting with the wind using constant-bank left turns and then twice
 using right turns.
 The acceleration components therefore have sinusoidal variations, and as
 shown in the figure the two independent measurements match very well.
 This checks the transformations and shows sufficient agreement without
 substantial noise, a requirement if the small difference is to be used
 to correct the measurements of heading.
 A similar plot, not shown, illustrated similar agreement in vertical components
 for a pitch maneuver in which the pitch of the aircraft is varied with
 about a 20
\begin_inset space \thinspace{}
\end_inset

s period while flying without roll and allowing the aircraft to climb and
 descend in response to the changes in pitch.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
Equations (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:ax-error"

\end_inset

--
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

) could then be used to estimate the heading error.
 However, if the accelerations (
\begin_inset Formula $a_{x},\,a_{y}$
\end_inset

) are small, as is common in straight-and-level flight, the resulting estimates
 may have large uncertainty.
 A more robust estimate is to calculate the difference 
\begin_inset Formula $\delta\psi=\psi_{g}-\psi_{a}$
\end_inset

 where 
\begin_inset Formula $\psi_{g}$
\end_inset

 is the angle obtained from the arctangent of the GPS-measured accelerations
 
\begin_inset Formula $\dot{V}$
\end_inset

 and 
\begin_inset Formula $\psi_{a}$
\end_inset

 is the corresponding angle obtained from the measured body accelerations
 after translation to the l
\emph on
-frame:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{align}
\psi_{g} & =\arctan\frac{\dot{V_{e}}}{\dot{V_{n}}}=\mathrm{atan2(\dot{V_{n}},\,\dot{V_{e}})}\label{eq:psi-g}\\
\psi_{a} & =\arctan\frac{a_{x}}{a_{y}}=\mathrm{atan2}(a_{y},\,a_{x})\label{eq:psi-a}
\end{align}

\end_inset


\emph default
A difference between these angles could arise from several sources:
\end_layout

\begin_layout Enumerate

\lang english
An error in the heading measurement would result in incorrect rotation of
 the measured accelerations to the 
\emph on
l
\emph default
-frame;
\end_layout

\begin_layout Enumerate

\lang english
There might be bias or scale errors in the accelerometers, leading to incorrect
 components of acceleration;
\end_layout

\begin_layout Enumerate

\lang english
There could be offsets in the times at which the measured accelerations
 and the GPS ground-speed components are measured.
 This would appear clearly in turns, where clockwise and counterclockwise
 turns would reverse sign if other effects are negligible.
\end_layout

\begin_layout Plain Layout

\lang english
These will be examined in following subsections.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Subsection

\lang english
The GPS-derived estimate of accelerations
\end_layout

\begin_layout Plain Layout

\lang english
The variables 
\begin_inset Formula $\dot{V_{n}}$
\end_inset

 and 
\begin_inset Formula $\dot{V_{e}}$
\end_inset

 must be found from derivatives of the GPS-measured velocity components.
 For this purpose, as in the pitch-correction algorithm, the choice made
 here is to estimate the derivatives using Savitzky-Golay polynomials, which
 are computationally efficient, don't introduce a time shift, and can provide
 derivatives directly.
 A rather long averaging period of 1009 s, or about 1/5 of a Schuler oscillation
, was used to reduce noise in the result, and interpolation filled some
 gaps in the measurements.
 The ground-speed components measured via GPS are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:sg-poly-smoothing1}
\end_layout

\end_inset

, and the derivative calculated and smoothed as described above is shown
 in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:sg-poly-smoothing2}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsection

\lang english
The 
\emph on
l
\emph default
-frame accelerations
\end_layout

\begin_layout Plain Layout

\lang english
The result of transforming the accelerations in the 
\emph on
b
\emph default
-frame to the 
\emph on
l
\emph default
-frame is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:get-b-vector-and-transform1}
\end_layout

\end_inset

.
 This flight was devoted to calibration maneuvers, so there are circle maneuvers
 (e.g., about 3:45:00), pitch maneuvers (e.g., about 4:27:00) and yaw maneuvers
 (e.g., about 4:33:00) as well as speed runs (e.g., about 5:05:00).
 This accounts for the large horizontal accelerations (in the circles) and
 the large vertical accelerations (in the pitch maneuvers).
 The good matches between measured accelerations translated to the 
\emph on
l
\emph default
-frame and those deduced from the derivative of the GPS-measured ground-speed
 components, shown in Figs.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:get-b-vector-and-transform2}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:get-b-vector-and-transform3}
\end_layout

\end_inset

 provide good evidence for the approach being taken and the suitability
 of the transformation used.
 One aspect that is troubling, however, is the poorer agreement for the
 vertical accelerations compared in Fig.\SpecialChar \-

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:get-b-vector-and-transform3}
\end_layout

\end_inset

, dotted-green vs red lines.
 Peak values for the measured accelerations consistently exceed those determined
 by differentiation of the rat-of-climb of the aircraft.
 [look into this further]
\end_layout

\begin_layout Subsection

\lang english
The differences in angles determined from the acceleration components
\end_layout

\begin_layout Plain Layout

\lang english
Equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

 is the basis for estimating the error in heading, so it is useful to consider
 the two terms in that equation and the combined prediction, to check for
 consistency.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:error-components}
\end_layout

\end_inset

 shows the two estimates of error and their combination as in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

).
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Some components of the transformation are neglected in this approach, specifical
ly those arising from the rotation of the Earth and the change in orientation
 of the 
\begin_inset Formula $l$
\end_inset

-frame as the aircraft moves over the surface of the Earth.
 
\begin_inset CommandInset citation
LatexCommand citet
key "noureldin2013fundamentals"

\end_inset

 [cf.
\begin_inset space ~
\end_inset

pp.
\begin_inset space ~
\end_inset

178--179] give the correction to be added to the 
\begin_inset Formula $l$
\end_inset

-frame velocity:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\mathbf{\boldsymbol{\Delta\dot{\mathbf{v}}}=}-(2\boldsymbol{\Omega}_{ie}^{l}+\boldsymbol{\Omega}_{el}^{l})\mathbf{v}^{(l)}\label{eq:rotation-correction}
\end{equation}

\end_inset

where the rotation matrices, respectively representing the Earth's rotation
 and the 
\begin_inset Formula $l$
\end_inset

-frame rotation, are
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\boldsymbol{\Omega}_{ie}^{l}=\left[\begin{array}{ccc}
0 & -\omega^{e}\sin\lambda & \omega^{e}\cos\lambda\\
\omega^{e}\sin\lambda & 0 & 0\\
-\omega^{e}\cos\lambda & 0 & 0
\end{array}\right]\label{eq:first-omega-eq}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\boldsymbol{\Omega}_{el}^{l}=\left[\begin{array}{ccc}
0 & \frac{-v_{e}\tan\lambda}{R_{e}} & \frac{v_{e}}{R_{e}}\\
\frac{v_{e}\tan\lambda}{R_{e}} & 0 & \frac{v_{n}}{R_{e}}\\
\frac{-v_{e}}{R_{e}} & \frac{-v_{n}}{R_{e}} & 0
\end{array}\right]\label{eq:second-omega-equation}
\end{equation}

\end_inset

with 
\begin_inset Formula $\lambda$
\end_inset

 the latitude, 
\begin_inset Formula $R_{e}$
\end_inset

 the radius of the earth,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A mean radius for the Earth, 
\begin_inset Formula $R_{e}=6.371\times10^{6}$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m, is used rather than the normal and meridional radii adjusted for height
 of the aircraft because this difference is insignificant for this application.
\end_layout

\end_inset

 and 
\begin_inset Formula $\omega^{e}=7.292\times10^{-5}$
\end_inset

 the angular rate of rotation of the Earth.
 Evaluation of the typical magnitudes arising from these rotation terms
 indicates that they are minor but not negligible, so this correction is
 added to the 
\begin_inset Formula $l$
\end_inset

-frame accelerations before comparison to the accelerations obtained by
 differentiating the GPS velocities.
\end_layout

\begin_layout Subsection
A proposed correction algorithm for heading
\end_layout

\begin_layout Standard
The requirements for this algorithm are as follows:
\end_layout

\begin_layout Itemize
The flight pattern must include maneuvers that provide horizontal accelerations,
 usually turns of at least 30
\begin_inset space \thinspace{}
\end_inset

s duration 
\emph on
in each direction.

\emph default
 The reason is that it is difficult to correct for timing errors in the
 measurements of heading relative to the measured ground-speed components
 from a GPS receiver, and even a delay of 50
\begin_inset space \thinspace{}
\end_inset

ms will, for a turn rate corresponding to a three-minute turn through 360
\begin_inset Formula $^{\circ}$
\end_inset

, lead to a 0.05
\begin_inset Formula $^{\circ}$
\end_inset

 false indication of a heading error.
 However, the error reverses sign with the direction of the turn, so averaging
 the results from left turns and from right turns will correct for this
 false indication of a heading error.
 Course-reversal maneuvers like 
\begin_inset Quotes eld
\end_inset

90-270
\begin_inset Quotes erd
\end_inset

 turns (90
\begin_inset Formula $^{\circ}$
\end_inset

 one direction followed by 270
\begin_inset Formula $^{\circ}$
\end_inset

 the other direction) provide good data for this algorithm, as do 
\begin_inset Quotes eld
\end_inset

60-300-60
\begin_inset Quotes erd
\end_inset

 teardrop turns that are a faster means of returning to the starting point.
 If wind measurements are critical to the research, it may be useful to
 include patterns like 
\begin_inset Quotes eld
\end_inset

S
\begin_inset Quotes erd
\end_inset

 turns periodically, with 30
\begin_inset space \thinspace{}
\end_inset

s turns in opposite directions, to provide the needed accelerations.
\end_layout

\begin_layout Itemize
To the extent possible, sampled time series should be corrected for sampling
 delays.
 The most important such correction is the timing of the heading measurement
 from the INS relative to the ground-speed measurements from the GPS.
 In the examples shown in this note, the differences between different turn
 directions were minimized by shifting the heading forward in time by 140
\begin_inset space \thinspace{}
\end_inset

ms.
 The averaging provided by the first item above helps reduce errors from
 timing, but it is still preferable to keep those errors small.
 Full-circle patterns flown in each turn direction provide a sensitive test
 of timing errors.
\end_layout

\begin_layout Standard
Many research flights and research data sets meet these requirements, and
 where wind measurement is important they can be incorporated into flight
 plans for future projects.
 The algorithm implemented here, for which specific R code is available,
 follows these steps:
\end_layout

\begin_layout Enumerate

\emph on
Shift the timing of the heading measurement as needed to match the GPS-receiver
 measurements of ground velocity.
 
\emph default

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\emph on
where necessary using fractional increments in the time series.

\emph default
 For example, the standard high-rate data sets provided by the NCAR/EOL/RAF
 data processing are 25
\begin_inset space \thinspace{}
\end_inset

Hz time series, so a shift of 140
\begin_inset space \thinspace{}
\end_inset

ms represents a 3.5-increment.
 This can be accomplished using interpolation to higher-rate series, filtering
 of the high-rate file, and resampling at the original rate.
\end_layout

\end_inset

The result of this procedure is very sensitive to differences in timing
 of measurements from the IRS and GPS, because in turns any lag appears
 as an offset in the accelerations that mimics a heading error.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\emph on
For data files produced at rates above 1
\begin_inset space \thinspace{}
\end_inset

Hz, construct a 1
\begin_inset space \thinspace{}
\end_inset

Hz data set to use when calculating the heading correction.

\emph default
 These results change only slowly, as suggested in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:spline-plot}
\end_layout

\end_inset

 Because the application of the transformations, differentiations, and pitch
 corrections require considerable calculation, this results in considerably
 faster calculations.
 
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\emph on
Optionally, apply pitch and roll corrections using the algorithm developed
 in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-pitch"

\end_inset

.
 
\emph default
The measurements of pitch and, to a lesser extent, roll affect the transformatio
n of the accelerations from the 
\begin_inset Formula $a$
\end_inset

-frame to the 
\begin_inset Formula $l$
\end_inset

-frame, but only have a very small effect, so omission of this step normally
 makes no detectable difference in the final heading correction..
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Although the correction developed here depends only weakly on the correction
 to pitch and roll, inclusion of this step may protect against or at least
 identify anomalously large errors in pitch.
 Reciprocally, the pitch correction depends on the measured heading, but
 the effect of heading errors are insignificant.
 Omission of this step normally makes no detectable difference.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\emph on
Differentiate the ground-speed measurements provided by a GPS receiver,
\emph default
 using third-order Savitzky-Golay polynomials spanning 21
\begin_inset space \thinspace{}
\end_inset

s, to obtain reference measurements of horizontal accelerations in the 
\begin_inset Formula $l$
\end_inset

-frame.
 
\end_layout

\begin_layout Enumerate

\emph on
Transform the accelerations measured by the INS in the 
\begin_inset Formula $a$
\end_inset

-frame to the 
\begin_inset Formula $l$
\end_inset

-frame
\emph default
, with the correction term specified by (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:rotation-correction"

\end_inset

).
 Filter these results also using Savitzky-Golay polynomials of the same
 order and span so that they are smoothed in the same way as the ground-speed
 derivatives.
\end_layout

\begin_layout Enumerate

\emph on
Use (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:final-answer"

\end_inset

) to obtain estimates of the heading error 
\begin_inset Formula $\delta\psi$
\end_inset

 at each time.

\emph default
 However, apply data restrictions to avoid cases of high uncertainty.
 The most important restriction used here was to require that the total
 horizontal acceleration in the 
\begin_inset Formula $l$
\end_inset

-frame be larger than 
\begin_inset Formula $1$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 
\end_layout

\begin_layout Enumerate

\emph on
Use a search algorithm to identify flight segments with turns
\emph default
 (specifically, magnitude of roll larger than 10
\begin_inset Formula $^{\circ}$
\end_inset

) continuously except for possible gaps of 5
\begin_inset space \thinspace{}
\end_inset

min.
 Require that these flight segments have both right and left turns, with
 at least 25
\begin_inset space \thinspace{}
\end_inset

s of each.
\end_layout

\begin_layout Enumerate

\emph on
For each such segment, calculate the mean correction
\emph default
 and its standard deviation and the mean time for each turn direction.
\end_layout

\begin_layout Enumerate

\emph on
Use cubic spline interpolation
\emph default
 to represent the variation in heading correction over the course of the
 flight.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Two possible choices are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:spline-plot}
\end_layout

\end_inset

; of these, the smoother choice is incorporated into the algorithm.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate

\emph on
Subtract the result given by this interopolation from the measured heading
 to obtain the corrected heading.
\end_layout

\begin_layout Subsection
Examples
\begin_inset CommandInset label
LatexCommand label
name "sub:Examples-roll"

\end_inset


\end_layout

\begin_layout Subsubsection
DEEPWAVE flight 15
\end_layout

\begin_layout Standard
DEEPWAVE flight 15 was devoted to calibration maneuvers and included three
 circle maneuvers like that shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:get-b-vector-and-transform}
\end_layout

\end_inset

 as well as some other maneuvers and turns that introduced horizontal accelerati
ons.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:error-components}
\end_layout

\end_inset

 shows the estimated heading error obtained from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:estimator-equation"

\end_inset

) for this flight.
 Values are plotted only where the total horizontal acceleration exceeded
 1
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

, the airspeed exceeded 130 m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 (to exclude periods of strong acceleration or deceleration near the start
 and end of the flight), and the absolute value of the rate of climb was
 less than 3
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 (to exclude climbs and descents).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<error-components, fig.height=4.5, include=TRUE, fig.cap="Heading error as
 estimated from (
\backslash

\backslash
ref{eq:estimator-equation}) for each 1-s measurement meeting the qualification
 test, for DEEPWAVE flight 15 (3 July 2014).">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# D$err1 <- (D$vedot - D$LACCX) / D$LACCY * 180/pi
\end_layout

\begin_layout Plain Layout

# D$err2 <- -(D$vndot - D$LACCY) / D$LACCX * 180/pi
\end_layout

\begin_layout Plain Layout

# hlim <- 0.1
\end_layout

\begin_layout Plain Layout

# D$herr <- D$err1
\end_layout

\begin_layout Plain Layout

# t <- abs(D$LACCY) < abs(D$LACCX)
\end_layout

\begin_layout Plain Layout

# D$herr[t] <- D$err2[t]
\end_layout

\begin_layout Plain Layout

# t <- abs(D$LACCX) + abs(D$LACCY) < hlim*2
\end_layout

\begin_layout Plain Layout

# D$herr[t] <- NA
\end_layout

\begin_layout Plain Layout

# D$herr <- zoo::na.approx (as.vector(D$herr), maxgap=100, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

# t <- is.na(D$herr)
\end_layout

\begin_layout Plain Layout

# D$herr[t] <- 0
\end_layout

\begin_layout Plain Layout

# D$herr <- signal::sgolayfilt (D$herr, 3, 1021, m=0)  
\end_layout

\begin_layout Plain Layout

# D$herr[t] <- NA
\end_layout

\begin_layout Plain Layout

# r <- setRange(D$Time, 33800,35500)
\end_layout

\begin_layout Plain Layout

# plotWAC (D[r, c("Time", "err1", "err2", "herr")], ylim=c(-10.,10.))
\end_layout

\begin_layout Plain Layout

D$ang1 <- atan2(D$vndot, D$vedot) / Cradeg
\end_layout

\begin_layout Plain Layout

D$ang2 <- atan2(D$LACCY, D$LACCX) / Cradeg
\end_layout

\begin_layout Plain Layout

#plotWAC(D[, c("Time", "ang1", "ang2")])
\end_layout

\begin_layout Plain Layout

#plotWAC(D$Time, D$ang1-D$ang2, ylim=c(-2,2))
\end_layout

\begin_layout Plain Layout

A2 <- D$LACCX^2 + D$LACCY^2
\end_layout

\begin_layout Plain Layout

A <- sqrt(A2)
\end_layout

\begin_layout Plain Layout

D$herr <- (-D$LACCY*(D$vedot-D$LACCX)+D$LACCX*(D$vndot-D$LACCY)) / (Cradeg*A2)
\end_layout

\begin_layout Plain Layout

#plotWAC(D$Time, D$herr, ylim=c(-2,2))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT <- D
\end_layout

\begin_layout Plain Layout

v <- DT$TASX > 130
\end_layout

\begin_layout Plain Layout

v <- v & (A > 1) & abs (D$herr) < 0.3 & abs(D$GGVSPD) < 3
\end_layout

\begin_layout Plain Layout

DT[!v,] <- NA
\end_layout

\begin_layout Plain Layout

plotWAC(DT$Time, DT$herr, ylim=c(-0.2,0.2), type='p', pch=20, col='blue',
\end_layout

\begin_layout Plain Layout

        ylab=expression(paste(delta,psi," [",degree,"]")))
\end_layout

\begin_layout Plain Layout

# he <- 0
\end_layout

\begin_layout Plain Layout

# tau <- 10
\end_layout

\begin_layout Plain Layout

# hea <- vector ('numeric', nrow(D))
\end_layout

\begin_layout Plain Layout

# k <- 0
\end_layout

\begin_layout Plain Layout

# for (i in 1:nrow(D)) {
\end_layout

\begin_layout Plain Layout

#   if (D$TASX[i] > 130 && A[i] > 1 && abs(D$herr[i]) < 0.3 && abs(D$GGVSPD[i])
 < 2) {
\end_layout

\begin_layout Plain Layout

#     he <- he + (D$herr[i]-he)/tau
\end_layout

\begin_layout Plain Layout

#     k <- k + 1
\end_layout

\begin_layout Plain Layout

#     if (k > 20) {tau = 60}
\end_layout

\begin_layout Plain Layout

#   }
\end_layout

\begin_layout Plain Layout

#   hea[i] <- he
\end_layout

\begin_layout Plain Layout

# }
\end_layout

\begin_layout Plain Layout

# lineWAC(D$Time, hea, col='red')
\end_layout

\begin_layout Plain Layout

ts <- DT[v,]
\end_layout

\begin_layout Plain Layout

meanDh <- mean(ts$herr)
\end_layout

\begin_layout Plain Layout

# plotWAC(ts[, c("Time", "herr"), ], ylab=expression(paste(delta,psi)))
\end_layout

\begin_layout Plain Layout

bf <- signal::butter(3,1/300)
\end_layout

\begin_layout Plain Layout

# ts$herr <- signal::filtfilt(bf, ts$herr)
\end_layout

\begin_layout Plain Layout

# lineWAC(ts$Time, ts$herr, col='red')
\end_layout

\begin_layout Plain Layout

D$hs <- rep(NA, nrow(DT))
\end_layout

\begin_layout Plain Layout

D$hs <- rep(meanDh, nrow(DT))
\end_layout

\begin_layout Plain Layout

for (i in 1:nrow(ts)) {
\end_layout

\begin_layout Plain Layout

  ix <- which(D$Time == ts$Time[i])
\end_layout

\begin_layout Plain Layout

  D$hs[ix] <- ts$herr[i]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

hs <- zoo::na.approx (as.vector(D$hs), maxgap=3000, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

hs <- signal::filtfilt(bf, hs)
\end_layout

\begin_layout Plain Layout

lineWAC(D$Time, hs, col='red')
\end_layout

\begin_layout Plain Layout

legend('topleft', legend=expression(paste("smoothed ",delta,psi)), col='red',
\end_layout

\begin_layout Plain Layout

       text.col='red', lwd=2, lty=1, bg='lightyellow')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The mean estimated heading error for this flight was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(meanDh,2)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

, so the indicated heading correction is significant and would change the
 lateral component of the horizontal wind by about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(meanDh*220*pi/180,1)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 for a representative flight speed of 220
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 Also shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:error-components}
\end_layout

\end_inset

, as a red line, is a smoothed representation of the heading correction.
 This was obtained using a third-order low-pass Butterworth filter with
 a cutoff frequency corresponding to a period of 5
\begin_inset space \thinspace{}
\end_inset

min to smooth departures from the mean only where the estimate of 
\begin_inset Formula $\delta\psi$
\end_inset

 was considered valid as defined above.:
\begin_inset Note Note
status collapsed

\begin_layout Enumerate
A new variable was initialized at the mean value of 
\begin_inset Formula $\delta\psi$
\end_inset

 for the flight.
\end_layout

\begin_layout Enumerate
At each point where there was a valid estimate of 
\begin_inset Formula $\delta\psi$
\end_inset

, as defined above and displayed as blue dots in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:error-components}
\end_layout

\end_inset

, the value of the new variable was replaced by that estimate.
\end_layout

\begin_layout Enumerate
The resulting time series was then filtered via a Butterworth third-order
 low-pass filter with a cutoff frequency corresponding to a period of 5
 min.
 The filtering was applied both forward and backward to minimize phase shift.
 (Short periods at the start and end then turn down toward zero are the
 result of zero-padding to initialize the filter.)
\end_layout

\begin_layout Plain Layout
The result was a smoothly varying estimate of the heading correction that,
 in this case, showed little variation over the time of the flight.
 The mean value of the correction, quoted above, is also a reasonable estimate
 of the correction for the entire flight.
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The result of this procedure is very sensitive to differences in timing
 of measurements from the IRS and GPS, because in turns any lag appears
 as an offset in the accelerations that mimics a heading error.
 In the circle maneuvers shown, the circles were flown first in left and
 then in right turns, so any timing errors would result in an offset between
 the estimated errors for the two turn directions.
 Simulated shifts in the signals showed that even a 10
\begin_inset space ~
\end_inset

ms shift led to an evident offset, so this is a very sensitive test of the
 accuracy of the signal timing.
 The fluctuations shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:error-components}
\end_layout

\end_inset

, for any of the indicated segments, can be eliminated by appropriate shifting
 of the heading measurement, but slightly different values are then required
 for each circle pattern so there may be small changes in the time shift
 of the heading measurement during the flight.
 When applied to another dataset or another aircraft, this is an important
 check that is made best by using circles such as were flown here.
 However, it may be best to find the time shift that minimizes these fluctuation
s, as done here, and then use the mean correction for the flight because
 there is no indication of a change with time for this case.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<correct-heading>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

CorrectHeading <- function (.data=Data, .span=21, .default=-0.08) {
\end_layout

\begin_layout Plain Layout

  ## note: before calling, should apply timing corrections and to pitch/roll
 corrections if desired.
\end_layout

\begin_layout Plain Layout

  GeneratePlot <- FALSE
\end_layout

\begin_layout Plain Layout

  Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

  RotationCorrection <- function (.data=Data, .V) {
\end_layout

\begin_layout Plain Layout

    Cradeg <- pi/180
\end_layout

\begin_layout Plain Layout

    omegaE <- StandardConstant ('Omega')
\end_layout

\begin_layout Plain Layout

    Re <- StandardConstant ('Re')
\end_layout

\begin_layout Plain Layout

    DL <- nrow (.data)
\end_layout

\begin_layout Plain Layout

    C <- vector ('numeric', 3*DL); dim(C) <- c(DL,3)
\end_layout

\begin_layout Plain Layout

    lat <- .data$LAT * Cradeg
\end_layout

\begin_layout Plain Layout

    sinLat <- sin(lat); cosLat <- cos(lat); tanLat <- tan(lat)
\end_layout

\begin_layout Plain Layout

    M12 <- -2*omegaE*sinLat-.V[,1]*tanLat/Re
\end_layout

\begin_layout Plain Layout

    M13 <- 2*omegaE*cosLat+.V[,1]/Re
\end_layout

\begin_layout Plain Layout

    M21 <- 2*omegaE*sinLat+.V[,1]*tanLat/Re
\end_layout

\begin_layout Plain Layout

    M23 <- .V[,2]/Re
\end_layout

\begin_layout Plain Layout

    M31 <- -2*omegaE*cosLat-.V[,1]/Re
\end_layout

\begin_layout Plain Layout

    M32 <- -.V[,2]/Re
\end_layout

\begin_layout Plain Layout

    C[,1] <- M12*.V[,2]+M13*.V[,3]
\end_layout

\begin_layout Plain Layout

    C[,2] <- M21*.V[,1]+M23*.V[,3]
\end_layout

\begin_layout Plain Layout

    C[,3] <- M31*.V[,1]+M32*.V[,2]
\end_layout

\begin_layout Plain Layout

    return (C)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  ## check for required variables:
\end_layout

\begin_layout Plain Layout

  Required <- c("BLATA", "BLONGA", "BNORMA", "GGVNS", "GGVEW", "GGALT",
\end_layout

\begin_layout Plain Layout

                "THDG", "PITCH", "ROLL")
\end_layout

\begin_layout Plain Layout

  .names <- names(.data)
\end_layout

\begin_layout Plain Layout

  for (.R in Required) {
\end_layout

\begin_layout Plain Layout

    if (.R %in% .names) {next}
\end_layout

\begin_layout Plain Layout

    print (sprintf ("in CorrectHeading, required variable %s not found;
 returning 0", .R))
\end_layout

\begin_layout Plain Layout

    return(0)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (!("LATC" %in% .names) && !("LAT" %in% .names)) {
\end_layout

\begin_layout Plain Layout

    print (sprintf ("in CorrectHeading, required variable LAT or LATC not
 found; returning 0"))
\end_layout

\begin_layout Plain Layout

    return(0)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  ## get the data rate
\end_layout

\begin_layout Plain Layout

  Rate <- 1  
\end_layout

\begin_layout Plain Layout

  if ((.data$Time[2]-.data$Time[1]) <= 0.04) {Rate <- 25} 
\end_layout

\begin_layout Plain Layout

  LD <- nrow(.data)
\end_layout

\begin_layout Plain Layout

  D <- .data[!is.na (.data$Time), ]  ## eliminate bad-time records
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  if (Rate > 1) {
\end_layout

\begin_layout Plain Layout

    D1 <- D[(as.numeric(D$Time) %% 1) < 0.01,]
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    D1 <- D
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  if ("PITCHC" %in% names (D1)) {D1$PITCH <- D1$PITCHC}
\end_layout

\begin_layout Plain Layout

  if ("ROLLC" %in% names (D1)) {D1$ROLL <- D1$ROLLC}
\end_layout

\begin_layout Plain Layout

  if ("LATC" %in% names (D1)) {D1$LAT <- D1$LATC}
\end_layout

\begin_layout Plain Layout

  # plotTrack(D1)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  #interpolate if necessary:
\end_layout

\begin_layout Plain Layout

  MaxGap <- 1000
\end_layout

\begin_layout Plain Layout

  ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BLONGA <- zoo::na.approx (as.vector (D1$BLONGA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BLATA <- zoo::na.approx (as.vector (D1$BLATA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BNORMA <- zoo::na.approx (as.vector (D1$BNORMA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$GGALT <- zoo::na.approx (as.vector (D1$GGALT), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$PITCH <- zoo::na.approx (as.vector (D1$PITCH), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$ROLL <- zoo::na.approx (as.vector (D1$ROLL), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$THDG <- zoo::na.approx (as.vector (D1$THDG), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$LAT <- zoo::na.approx (as.vector (D1$LAT), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  vndot <- signal::sgolayfilt (ggvns, 3, .span, m=1)  # m=1 for first deriv.
\end_layout

\begin_layout Plain Layout

  vedot <- signal::sgolayfilt (ggvew, 3, .span, m=1)
\end_layout

\begin_layout Plain Layout

  G <- Gravity (D1$LAT, D1$GGALT)
\end_layout

\begin_layout Plain Layout

  AV <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame
\end_layout

\begin_layout Plain Layout

  LV <- XformLA (D1, AV)                                    #l-frame
\end_layout

\begin_layout Plain Layout

  ## now corrected for angular effects
\end_layout

\begin_layout Plain Layout

  ## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

  LV <- LV - RotationCorrection (D1, LV)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  D1$LACCX <- LV[, 1]
\end_layout

\begin_layout Plain Layout

  D1$LACCY <- LV[, 2]
\end_layout

\begin_layout Plain Layout

  D1$LACCZ <- LV[, 3] + G
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

  D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

  D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, .span, m=0)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  A2 <- D1$LACCX^2 + D1$LACCY^2
\end_layout

\begin_layout Plain Layout

  A <- sqrt(A2)
\end_layout

\begin_layout Plain Layout

  D1$herr <- (-D1$LACCY*(vedot-D1$LACCX)+D1$LACCX*(vndot-D1$LACCY)) / (Cradeg*A2
)
\end_layout

\begin_layout Plain Layout

  DT <- D1
\end_layout

\begin_layout Plain Layout

  v <- DT$TASX > 130
\end_layout

\begin_layout Plain Layout

  v <- v & (A > 1) & abs (DT$herr) < 0.3 & abs(DT$GGVSPD) < 3
\end_layout

\begin_layout Plain Layout

  DT[!v,] <- NA
\end_layout

\begin_layout Plain Layout

  r <- DT$ROLL > 10
\end_layout

\begin_layout Plain Layout

  l <- DT$ROLL < -10
\end_layout

\begin_layout Plain Layout

  DT$TestR <- (!is.na(DT$Time) & (DT$ROLL > 10))
\end_layout

\begin_layout Plain Layout

  DT$TestL <- (!is.na(DT$Time) & (DT$ROLL < -10))
\end_layout

\begin_layout Plain Layout

  DSET <- data.frame ()
\end_layout

\begin_layout Plain Layout

  set <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  hmean <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  hsd <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  tbar <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  hmeanR <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  hsdR <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  tbarR <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  hmeanL <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  hsdL <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  tbarL <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  setStart <- 0
\end_layout

\begin_layout Plain Layout

  NRA <- 40    ## effective averaging seconds for error-bar std.
 dev.
\end_layout

\begin_layout Plain Layout

  NSL <- 25    ## required seconds turn in each direction
\end_layout

\begin_layout Plain Layout

  TGAP <- 300  ## seconds constituting break in sets of turn values
\end_layout

\begin_layout Plain Layout

  for (k in 1:nrow(DT)) {
\end_layout

\begin_layout Plain Layout

    if (DT$TestR[k] || DT$TestL[k]) {
\end_layout

\begin_layout Plain Layout

      if (setStart == 0) {
\end_layout

\begin_layout Plain Layout

        setStart <- k
\end_layout

\begin_layout Plain Layout

        setEnd <- k
\end_layout

\begin_layout Plain Layout

        DSET <- rbind(DSET, DT[k,])
\end_layout

\begin_layout Plain Layout

      } else if (as.numeric(difftime(DT$Time[k], DT$Time[setEnd], units='sec'))
 > TGAP) {
\end_layout

\begin_layout Plain Layout

        if (length(DSET[DSET$TestR == TRUE, "herr"]) > NSL &&
\end_layout

\begin_layout Plain Layout

            length(DSET[DSET$TestL == TRUE, "herr"]) > NSL) {      
\end_layout

\begin_layout Plain Layout

          hmnR <- mean (DSET$herr[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

          hmnL <- mean (DSET$herr[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

          hsdevR <- sd (DSET$herr[DSET$TestR], na.rm=TRUE) / 
\end_layout

\begin_layout Plain Layout

            sqrt (length (DSET$TestR)/NRA)
\end_layout

\begin_layout Plain Layout

          hsdevL <- sd (DSET$herr[DSET$TestL], na.rm=TRUE) / 
\end_layout

\begin_layout Plain Layout

            sqrt (length (DSET$TestL)/NRA)
\end_layout

\begin_layout Plain Layout

          tbrR <- mean(DSET$Time[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

          tbrL <- mean(DSET$Time[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

          # print (sprintf ("R time %s count %d", as.POSIXct (tbrR, origin="2014-
07-04", tz="GMT"), length(DSET$TestR)))
\end_layout

\begin_layout Plain Layout

          hmeanR <- c(hmeanR, hmnR)
\end_layout

\begin_layout Plain Layout

          hsdR   <- c(hsdR, hsdevR)
\end_layout

\begin_layout Plain Layout

          tbarR  <- c(tbarR, tbrR)
\end_layout

\begin_layout Plain Layout

          # print (sprintf ("L time %s count %d", as.POSIXct (tbrL, origin="2014-
07-04", tz="GMT"), length(DSET$TestL)))
\end_layout

\begin_layout Plain Layout

          hmeanL <- c(hmeanL, hmnL)
\end_layout

\begin_layout Plain Layout

          hsdL   <- c(hsdL, hsdevL)
\end_layout

\begin_layout Plain Layout

          tbarL  <- c(tbarL, tbrL)
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        setStart <- k
\end_layout

\begin_layout Plain Layout

        setEnd <- k
\end_layout

\begin_layout Plain Layout

        DSET <- DT[k,]
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        setEnd <- k
\end_layout

\begin_layout Plain Layout

        DSET <- rbind(DSET, DT[k,])
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (length(DSET[DSET$TestR == TRUE, "herr"]) > NSL &&
\end_layout

\begin_layout Plain Layout

      length(DSET[DSET$TestL == TRUE, "herr"]) > NSL) { 
\end_layout

\begin_layout Plain Layout

    hmnR <- mean (DSET$herr[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    hmnL <- mean (DSET$herr[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    hsdevR <- sd (DSET$herr[DSET$TestR], na.rm=TRUE) / sqrt (length (DSET$TestR)/
NRA)
\end_layout

\begin_layout Plain Layout

    hsdevL <- sd (DSET$herr[DSET$TestL], na.rm=TRUE) / sqrt (length (DSET$TestL)/
NRA)
\end_layout

\begin_layout Plain Layout

    tbrR <- mean(DSET$Time[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    tbrL <- mean(DSET$Time[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    hmeanR <- c(hmeanR, hmnR)
\end_layout

\begin_layout Plain Layout

    hsdR   <- c(hsdR, hsdevR)
\end_layout

\begin_layout Plain Layout

    tbarR  <- c(tbarR, tbrR)
\end_layout

\begin_layout Plain Layout

    hmeanL <- c(hmeanL, hmnL)
\end_layout

\begin_layout Plain Layout

    hsdL   <- c(hsdL, hsdevL)
\end_layout

\begin_layout Plain Layout

    tbarL  <- c(tbarL, tbrL)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (length (tbarL) < 3) {
\end_layout

\begin_layout Plain Layout

    print (sprintf ("CorrectHeading found too few qualifying turns (%d),
\backslash
nso return is default of -0.08", length (tbarL)))
\end_layout

\begin_layout Plain Layout

    return (c(rep(.default, LD)))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (GeneratePlot) {
\end_layout

\begin_layout Plain Layout

    clr <- c("right", "left", "spline")
\end_layout

\begin_layout Plain Layout

    col <- c ('blue', 'darkgreen', "red")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  EH <- data.frame(tbar=c(tbarL, tbarR), hmeanR=c(rep(NA, length(tbarL)),
 hmeanR),
\end_layout

\begin_layout Plain Layout

                   hmeanL=c(hmeanL, rep(NA, length(tbarR))), 
\end_layout

\begin_layout Plain Layout

                   hsdR=c(rep(NA, length(tbarL)), hsdR), 
\end_layout

\begin_layout Plain Layout

                   hsdL=c(hsdL, rep(NA, length(tbarR))))
\end_layout

\begin_layout Plain Layout

  EH$tbar <- as.POSIXct (EH$tbar, origin="1970-01-01", tz="GMT")
\end_layout

\begin_layout Plain Layout

  ## whmean and whsd are not used; left here for reference
\end_layout

\begin_layout Plain Layout

  whmean <- weighted.mean (c(EH$hmeanR, EH$hmeanL), 
\end_layout

\begin_layout Plain Layout

                           c(1/EH$hsdR^2, 1/EH$hsdL^2), na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  whsd <- sqrt (1/sum(c(1/EH$hsdR^2, 1/EH$hsdL^2), na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

  if (GeneratePlot) {
\end_layout

\begin_layout Plain Layout

    p <- ggplot(EH, aes(x=tbar), na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    p <- p + geom_errorbar(aes(ymin=hmeanR-hsdR, ymax=hmeanR+hsdR, colour=clr[1]
),
\end_layout

\begin_layout Plain Layout

                           width=600, size=1.5, na.rm=TRUE) + ylim (-0.25,0.15)
\end_layout

\begin_layout Plain Layout

    p <- p + geom_point (aes(y = hmeanR, colour=clr[1]),size=3.5, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    p <- p + geom_errorbar(aes(ymin=hmeanL-hsdL, ymax=hmeanL+hsdL, colour=clr[2]
),
\end_layout

\begin_layout Plain Layout

                           width=600, size=1.5, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    p <- p + geom_point (aes(y = hmeanL, colour=clr[2]), size=3.5, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    p <- p + ylab(expression(paste(delta,psi,' [',degree,']')))
\end_layout

\begin_layout Plain Layout

    p <- p + xlab ("Time [UTC]")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  yss <- c(EH$hmeanL[!is.na(EH$hmeanL)], EH$hmeanR[!is.na(EH$hmeanR)])
\end_layout

\begin_layout Plain Layout

  ywts <- 1/c(EH$hsdL[!is.na(EH$hsdL)], EH$hsdR[!is.na(EH$hsdR)])^2
\end_layout

\begin_layout Plain Layout

  SS <- smooth.spline(EH$tbar, yss, w=ywts, df=length(yss)-1, spar=0.7)
\end_layout

\begin_layout Plain Layout

  # # xss <- as.POSIXct (SS$x, origin="1970-01-01", tz="GMT")
\end_layout

\begin_layout Plain Layout

  # # p <- p + geom_line(aes(x=xss, y=SS$y, colour=clr[3]), lwd=2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  if (GeneratePlot) {
\end_layout

\begin_layout Plain Layout

    D1$HC <- predict(SS, as.numeric(D1$Time))$y
\end_layout

\begin_layout Plain Layout

    p <- p + geom_line (data=D1, aes (x=Time, y=HC, colour=clr[3]), lwd=2,
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    # SS2 <- smooth.spline(EH$tbar, yss, df=8, spar=0.4)
\end_layout

\begin_layout Plain Layout

    # xss2 <- as.POSIXct (SS2$x, origin="1970-01-01", tz="GMT")
\end_layout

\begin_layout Plain Layout

    # p <- p + geom_line(aes(x=xss2, y=SS2$y, colour=clr[3]), lwd=2, lty=2,
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    cols <- c("right"="blue", "left"="darkgreen", "spline"="red")
\end_layout

\begin_layout Plain Layout

    p <- p + scale_colour_manual("turn direction:", values=cols)
\end_layout

\begin_layout Plain Layout

    p <- p + guides(color=guide_legend(override.aes=list(shape=c(16,16,NA),
 
\end_layout

\begin_layout Plain Layout

                                                         linetype=c(0,0,1))))
\end_layout

\begin_layout Plain Layout

    p <- p + theme_WAC()
\end_layout

\begin_layout Plain Layout

    print (p)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ## construct the input-rate heading correction HC
\end_layout

\begin_layout Plain Layout

  HC <- predict(SS, as.numeric(D$Time))$y
\end_layout

\begin_layout Plain Layout

  return (HC)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plot-heading-correction-rf15, include=TRUE, fig.height=4, fig.cap="The heading
 correction determined using the proposed algorithm, for the measurements
 from DEEPWAVE flight 15 (3 July 2014).
 Estimates from left and right turns are plotted separately and an interpolating
 spline fit is also shown.
 Error bars are approximately $2
\backslash

\backslash
sigma_m$ where $
\backslash

\backslash
sigma_m$ is the standard deviation in the mean value.">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  .data <- D
\end_layout

\begin_layout Plain Layout

  GeneratePlot <- TRUE
\end_layout

\begin_layout Plain Layout

  PC <- CorrectPitch (.data)
\end_layout

\begin_layout Plain Layout

  .data$PITCHC <- .data$PITCH - PC[, 1]
\end_layout

\begin_layout Plain Layout

  Rate <- 1  
\end_layout

\begin_layout Plain Layout

  if ((.data$Time[2]-.data$Time[1]) <= 0.04) {Rate <- 25} 
\end_layout

\begin_layout Plain Layout

  LD <- nrow(.data)
\end_layout

\begin_layout Plain Layout

  ## Note: apply shift in time before calling, and
\end_layout

\begin_layout Plain Layout

  ##       do pitch correction if desired
\end_layout

\begin_layout Plain Layout

  D <- .data[!is.na (.data$Time), ]
\end_layout

\begin_layout Plain Layout

  if ("PITCHC" %in% names (D)) {D$PITCH <- D$PITCHC}
\end_layout

\begin_layout Plain Layout

  if ("ROLLC" %in% names (D)) {D$ROLL <- D$ROLLC}
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  if (Rate > 1) {
\end_layout

\begin_layout Plain Layout

    D1 <- D[(as.numeric(D$Time) %% 1) < 0.01,]
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    D1 <- D
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  # plotTrack(D1)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  #interpolate if necessary:
\end_layout

\begin_layout Plain Layout

  MaxGap <- 1000
\end_layout

\begin_layout Plain Layout

  ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  vndot <- signal::sgolayfilt (ggvns, 3, 21, m=1)  # m=1 for first deriv.
\end_layout

\begin_layout Plain Layout

  vedot <- signal::sgolayfilt (ggvew, 3, 21, m=1)
\end_layout

\begin_layout Plain Layout

  D1$BLONGA <- zoo::na.approx (as.vector (D1$BLONGA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BLATA <- zoo::na.approx (as.vector (D1$BLATA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$BNORMA <- zoo::na.approx (as.vector (D1$BNORMA), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$PITCH <- zoo::na.approx (as.vector (D1$PITCH), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$PITCHC <- zoo::na.approx (as.vector (D1$PITCHC), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$ROLL <- zoo::na.approx (as.vector (D1$ROLL), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$THDG <- zoo::na.approx (as.vector (D1$THDG), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  D1$LATC <- zoo::na.approx (as.vector (D1$LATC), maxgap=MaxGap, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

  G <- Gravity (D1$LATC, D1$GGALT)
\end_layout

\begin_layout Plain Layout

  AV <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame
\end_layout

\begin_layout Plain Layout

  LV <- XformLA (D1, AV)                                    #l-frame
\end_layout

\begin_layout Plain Layout

  ## now corrected for angular effects
\end_layout

\begin_layout Plain Layout

  ## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

  LV <- LV - RotationCorrection (D1, LV)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  D1$LACCX <- LV[, 1]
\end_layout

\begin_layout Plain Layout

  D1$LACCY <- LV[, 2]
\end_layout

\begin_layout Plain Layout

  D1$LACCZ <- LV[, 3] + G
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, 21, m=0)
\end_layout

\begin_layout Plain Layout

  D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, 21, m=0)
\end_layout

\begin_layout Plain Layout

  D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, 21, m=0)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  A2 <- D1$LACCX^2 + D1$LACCY^2
\end_layout

\begin_layout Plain Layout

  A <- sqrt(A2)
\end_layout

\begin_layout Plain Layout

  D1$herr <- (-D1$LACCY*(vedot-D1$LACCX)+D1$LACCX*(vndot-D1$LACCY)) / (Cradeg*A2
)
\end_layout

\begin_layout Plain Layout

  DT <- D1
\end_layout

\begin_layout Plain Layout

  v <- DT$TASX > 130
\end_layout

\begin_layout Plain Layout

  v <- v & (A > 1) & abs (DT$herr) < 0.3 & abs(DT$GGVSPD) < 3
\end_layout

\begin_layout Plain Layout

  DT[!v,] <- NA
\end_layout

\begin_layout Plain Layout

  r <- DT$ROLL > 10
\end_layout

\begin_layout Plain Layout

  l <- DT$ROLL < -10
\end_layout

\begin_layout Plain Layout

  DT$TestR <- (!is.na(DT$Time) & (DT$ROLL > 10))
\end_layout

\begin_layout Plain Layout

  DT$TestL <- (!is.na(DT$Time) & (DT$ROLL < -10))
\end_layout

\begin_layout Plain Layout

  DSET <- data.frame ()
\end_layout

\begin_layout Plain Layout

  set <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  hmean <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  hsd <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  tbar <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  hmeanR <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  hsdR <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  tbarR <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  hmeanL <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  hsdL <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  tbarL <- vector("numeric")
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  setStart <- 0
\end_layout

\begin_layout Plain Layout

  NRA <- 40    ## effective averaging seconds for error-bar std.
 dev.
\end_layout

\begin_layout Plain Layout

  NSL <- 25    ## required seconds turn in each direction
\end_layout

\begin_layout Plain Layout

  TGAP <- 300  ## seconds constituting break in sets of turn values
\end_layout

\begin_layout Plain Layout

  for (k in 1:nrow(DT)) {
\end_layout

\begin_layout Plain Layout

    if (DT$TestR[k] || DT$TestL[k]) {
\end_layout

\begin_layout Plain Layout

      if (setStart == 0) {
\end_layout

\begin_layout Plain Layout

        setStart <- k
\end_layout

\begin_layout Plain Layout

        setEnd <- k
\end_layout

\begin_layout Plain Layout

        DSET <- rbind(DSET, DT[k,])
\end_layout

\begin_layout Plain Layout

      } else if (as.numeric(difftime(DT$Time[k], DT$Time[setEnd], units='sec'))
 > TGAP) {
\end_layout

\begin_layout Plain Layout

        if (length(DSET[DSET$TestR == TRUE, "herr"]) > NSL &&
\end_layout

\begin_layout Plain Layout

            length(DSET[DSET$TestL == TRUE, "herr"]) > NSL) {      
\end_layout

\begin_layout Plain Layout

          hmnR <- mean (DSET$herr[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

          hmnL <- mean (DSET$herr[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

          hsdevR <- sd (DSET$herr[DSET$TestR], na.rm=TRUE) / 
\end_layout

\begin_layout Plain Layout

            sqrt (length (DSET$TestR)/NRA)
\end_layout

\begin_layout Plain Layout

          hsdevL <- sd (DSET$herr[DSET$TestL], na.rm=TRUE) / 
\end_layout

\begin_layout Plain Layout

            sqrt (length (DSET$TestL)/NRA)
\end_layout

\begin_layout Plain Layout

          tbrR <- mean(DSET$Time[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

          tbrL <- mean(DSET$Time[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

          # print (sprintf ("R time %s count %d", as.POSIXct (tbrR, origin="2014-
07-04", tz="GMT"), length(DSET$TestR)))
\end_layout

\begin_layout Plain Layout

          hmeanR <- c(hmeanR, hmnR)
\end_layout

\begin_layout Plain Layout

          hsdR   <- c(hsdR, hsdevR)
\end_layout

\begin_layout Plain Layout

          tbarR  <- c(tbarR, tbrR)
\end_layout

\begin_layout Plain Layout

          # print (sprintf ("L time %s count %d", as.POSIXct (tbrL, origin="2014-
07-04", tz="GMT"), length(DSET$TestL)))
\end_layout

\begin_layout Plain Layout

          hmeanL <- c(hmeanL, hmnL)
\end_layout

\begin_layout Plain Layout

          hsdL   <- c(hsdL, hsdevL)
\end_layout

\begin_layout Plain Layout

          tbarL  <- c(tbarL, tbrL)
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        setStart <- k
\end_layout

\begin_layout Plain Layout

        setEnd <- k
\end_layout

\begin_layout Plain Layout

        DSET <- DT[k,]
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        setEnd <- k
\end_layout

\begin_layout Plain Layout

        DSET <- rbind(DSET, DT[k,])
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (length(DSET[DSET$TestR == TRUE, "herr"]) > NSL &&
\end_layout

\begin_layout Plain Layout

      length(DSET[DSET$TestL == TRUE, "herr"]) > NSL) { 
\end_layout

\begin_layout Plain Layout

    hmnR <- mean (DSET$herr[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    hmnL <- mean (DSET$herr[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    hsdevR <- sd (DSET$herr[DSET$TestR], na.rm=TRUE) / sqrt (length (DSET$TestR)/
NRA)
\end_layout

\begin_layout Plain Layout

    hsdevL <- sd (DSET$herr[DSET$TestL], na.rm=TRUE) / sqrt (length (DSET$TestL)/
NRA)
\end_layout

\begin_layout Plain Layout

    tbrR <- mean(DSET$Time[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    tbrL <- mean(DSET$Time[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    hmeanR <- c(hmeanR, hmnR)
\end_layout

\begin_layout Plain Layout

    hsdR   <- c(hsdR, hsdevR)
\end_layout

\begin_layout Plain Layout

    tbarR  <- c(tbarR, tbrR)
\end_layout

\begin_layout Plain Layout

    hmeanL <- c(hmeanL, hmnL)
\end_layout

\begin_layout Plain Layout

    hsdL   <- c(hsdL, hsdevL)
\end_layout

\begin_layout Plain Layout

    tbarL  <- c(tbarL, tbrL)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  if (GeneratePlot) {
\end_layout

\begin_layout Plain Layout

    clr <- c("right", "left", "spline")
\end_layout

\begin_layout Plain Layout

    col <- c ('blue', 'darkgreen', "red")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  EH <- data.frame(tbar=c(tbarL, tbarR), hmeanR=c(rep(NA, length(tbarL)),
 hmeanR),
\end_layout

\begin_layout Plain Layout

                   hmeanL=c(hmeanL, rep(NA, length(tbarR))), 
\end_layout

\begin_layout Plain Layout

                   hsdR=c(rep(NA, length(tbarL)), hsdR), 
\end_layout

\begin_layout Plain Layout

                   hsdL=c(hsdL, rep(NA, length(tbarR))))
\end_layout

\begin_layout Plain Layout

  EH$tbar <- as.POSIXct (EH$tbar, origin="1970-01-01", tz="GMT")
\end_layout

\begin_layout Plain Layout

  whmean15 <- weighted.mean (c(EH$hmeanR, EH$hmeanL), 
\end_layout

\begin_layout Plain Layout

                           c(1/EH$hsdR^2, 1/EH$hsdL^2), na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  whsd15 <- sqrt (1/sum(c(1/EH$hsdR^2, 1/EH$hsdL^2), na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

  if (GeneratePlot) {
\end_layout

\begin_layout Plain Layout

    p <- ggplot(EH, aes(x=tbar), na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    p <- p + geom_errorbar(aes(ymin=hmeanR-hsdR, ymax=hmeanR+hsdR, colour=clr[1]
),
\end_layout

\begin_layout Plain Layout

                           width=600, size=1.5, na.rm=TRUE) + ylim (-0.25,0.15)
\end_layout

\begin_layout Plain Layout

    p <- p + geom_point (aes(y = hmeanR, colour=clr[1]),size=3.5, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    p <- p + geom_errorbar(aes(ymin=hmeanL-hsdL, ymax=hmeanL+hsdL, colour=clr[2]
),
\end_layout

\begin_layout Plain Layout

                           width=600, size=1.5, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    p <- p + geom_point (aes(y = hmeanL, colour=clr[2]), size=3.5, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    p <- p + ylab(expression(paste(delta,psi,' [',degree,']')))
\end_layout

\begin_layout Plain Layout

    p <- p + xlab ("Time [UTC]")
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  yss <- c(EH$hmeanL[!is.na(EH$hmeanL)], EH$hmeanR[!is.na(EH$hmeanR)])
\end_layout

\begin_layout Plain Layout

  SS <- smooth.spline(EH$tbar, yss, df=length(yss)-1, spar=0.7)
\end_layout

\begin_layout Plain Layout

  # # xss <- as.POSIXct (SS$x, origin="1970-01-01", tz="GMT")
\end_layout

\begin_layout Plain Layout

  # # p <- p + geom_line(aes(x=xss, y=SS$y, colour=clr[3]), lwd=2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  D1$HC <- predict(SS, as.numeric(D1$Time))$y
\end_layout

\begin_layout Plain Layout

  if (GeneratePlot) {
\end_layout

\begin_layout Plain Layout

    p <- p + geom_line (data=D1, aes (x=Time, y=HC, colour=clr[3]), lwd=2,
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    # SS2 <- smooth.spline(EH$tbar, yss, df=8, spar=0.4)
\end_layout

\begin_layout Plain Layout

    # xss2 <- as.POSIXct (SS2$x, origin="1970-01-01", tz="GMT")
\end_layout

\begin_layout Plain Layout

    # p <- p + geom_line(aes(x=xss2, y=SS2$y, colour=clr[3]), lwd=2, lty=2,
 na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

    cols <- c("right"="blue", "left"="darkgreen", "spline"="red")
\end_layout

\begin_layout Plain Layout

    p <- p + scale_colour_manual("turn direction:", values=cols)
\end_layout

\begin_layout Plain Layout

    p <- p + guides(color=guide_legend(override.aes=list(shape=c(16,16,NA),
 
\end_layout

\begin_layout Plain Layout

                                                         linetype=c(0,0,1))))
\end_layout

\begin_layout Plain Layout

    p <- p + theme_WAC()
\end_layout

\begin_layout Plain Layout

    print (p)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:plot-heading-correction-rf15}
\end_layout

\end_inset

 shows the result from application of the proposed algorithm, as the red
 line.
 This result is reasonably consistent with that shown in the previous figure,
 but provides an estimated error that varies more slowly over the course
 of the flight.
 The weighted mean error obtained in this way is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(whmean15,2)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

 with weighted standard deviation of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(whsd15,2)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
DEEPWAVE flight 16
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<flight-16, include=FALSE, fig.cap="Flight track of DEEPWAVE flight 16,
 July 4 2014, with repeated passes over the South Island of New Zealand.
 Times are HH:MM UTC.">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# require(maps)
\end_layout

\begin_layout Plain Layout

# require(mapdata)
\end_layout

\begin_layout Plain Layout

# require(mapproj)
\end_layout

\begin_layout Plain Layout

Flight <- "rf16h" 
\end_layout

\begin_layout Plain Layout

fname <- sprintf ("%s%s/%s%s.nc", DataDirectory(), Project, Project, Flight)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SaveRData4 <- sprintf("DataFrames/%s4.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  Data <- getNetCDF(fname, standardVariables(VarNames))
\end_layout

\begin_layout Plain Layout

  save (Data, file=SaveRData4)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file=SaveRData4)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

##### TEMPORARY #####
\end_layout

\begin_layout Plain Layout

# print("heading adjustment applied as test of sign")
\end_layout

\begin_layout Plain Layout

# Data$THDG <- Data$THDG + 0.08
\end_layout

\begin_layout Plain Layout

#####################
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Rate <- 1  
\end_layout

\begin_layout Plain Layout

if ((Data$Time[2]-Data$Time[1]) <= 0.04) {Rate <- 25} 
\end_layout

\begin_layout Plain Layout

LD <- nrow(Data)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D <- Data[!is.na (Data$Time), ]
\end_layout

\begin_layout Plain Layout

s <- -60
\end_layout

\begin_layout Plain Layout

D$THDG <- ShiftInTime (D$THDG, Rate, s)
\end_layout

\begin_layout Plain Layout

D$VEW <- ShiftInTime (D$VEW, Rate, s)    ## this is needed for pitch correction
\end_layout

\begin_layout Plain Layout

D$VNS <- ShiftInTime (D$VNS, Rate, s)
\end_layout

\begin_layout Plain Layout

D$BLONGA <- ShiftInTime (D$BLONGA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

D$BLATA <- ShiftInTime (D$BLATA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

D$BNORMA <- ShiftInTime (D$BNORMA, Rate, s-80)
\end_layout

\begin_layout Plain Layout

C <- CorrectPitch(D)
\end_layout

\begin_layout Plain Layout

D$PITCHC <- D$PITCH - C[,1]
\end_layout

\begin_layout Plain Layout

D$ROLLC  <- D$ROLL  - C[,2]
\end_layout

\begin_layout Plain Layout

DataSave <- D
\end_layout

\begin_layout Plain Layout

D$PITCH <- D$PITCHC
\end_layout

\begin_layout Plain Layout

D$ROLL <- D$ROLLC
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (Rate > 1) {
\end_layout

\begin_layout Plain Layout

  D1 <- D[(as.numeric(D$Time) %% 1) < 0.01,]
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  D1 <- D
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# plotTrack(D1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#interpolate if necessary:
\end_layout

\begin_layout Plain Layout

MaxGap <- 1000
\end_layout

\begin_layout Plain Layout

ggvns <- zoo::na.approx (as.vector(D1$GGVNS), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

ggvew <- zoo::na.approx (as.vector(D1$GGVEW), maxgap=MaxGap, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

vndot <- signal::sgolayfilt (ggvns, 3, 21, m=1)  # m=1 for first deriv.
\end_layout

\begin_layout Plain Layout

vedot <- signal::sgolayfilt (ggvew, 3, 21, m=1)
\end_layout

\begin_layout Plain Layout

G <- Gravity (D1$LATC, D1$GGALT)
\end_layout

\begin_layout Plain Layout

AV <- matrix(c(D1$BLONGA, D1$BLATA, D1$BNORMA+G), ncol=3) #aircraft-frame
\end_layout

\begin_layout Plain Layout

LV <- XformLA (D1, AV)                                  #l-frame
\end_layout

\begin_layout Plain Layout

## now corrected for angular effects
\end_layout

\begin_layout Plain Layout

## See Noureldin et al, 2013, Eq.
 (5.55)
\end_layout

\begin_layout Plain Layout

LV <- LV - RotationCorrection (D1, LV)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D1$LACCX <- LV[, 1]
\end_layout

\begin_layout Plain Layout

D1$LACCY <- LV[, 2]
\end_layout

\begin_layout Plain Layout

D1$LACCZ <- LV[, 3] + G
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

D1$LACCX <- signal::sgolayfilt (D1$LACCX, 3, 21, m=0)
\end_layout

\begin_layout Plain Layout

D1$LACCY <- signal::sgolayfilt (D1$LACCY, 3, 21, m=0)
\end_layout

\begin_layout Plain Layout

D1$LACCZ <- signal::sgolayfilt (D1$LACCZ, 3, 21, m=0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<errors-rf16, fig.height=4.5, include=FALSE, fig.cap="Heading error as estimated
 from (
\backslash

\backslash
ref{eq:estimator-equation}) for DEEPWAVE flight 16.">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

A2 <- D1$LACCX^2 + D1$LACCY^2
\end_layout

\begin_layout Plain Layout

A <- sqrt(A2)
\end_layout

\begin_layout Plain Layout

D1$herr <- (-D1$LACCY*(vedot-D1$LACCX)+D1$LACCX*(vndot-D1$LACCY)) / (Cradeg*A2)
\end_layout

\begin_layout Plain Layout

# plotWAC(D$Time, D$herr, ylim=c(-2,2))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT <- D1
\end_layout

\begin_layout Plain Layout

v <- DT$TASX > 130
\end_layout

\begin_layout Plain Layout

v <- v & (A > 1) & abs (DT$herr) < 0.3 & abs(DT$GGVSPD) < 3
\end_layout

\begin_layout Plain Layout

DT[!v,] <- NA
\end_layout

\begin_layout Plain Layout

r <- setRange(D1$Time, 80000, 82500)
\end_layout

\begin_layout Plain Layout

r <- setRange(D1$Time, 0, 0)
\end_layout

\begin_layout Plain Layout

r <- DT$ROLL > 10
\end_layout

\begin_layout Plain Layout

l <- DT$ROLL < -10
\end_layout

\begin_layout Plain Layout

plotWAC(DT$Time[r], DT$herr[r], ylim=c(-0.5,0.5), type='p', pch=20, col='blue',
\end_layout

\begin_layout Plain Layout

        ylab=expression(paste(delta,psi)))
\end_layout

\begin_layout Plain Layout

lineWAC(DT$Time[l], DT$herr[l], type='p', pch=20, col='darkgreen')
\end_layout

\begin_layout Plain Layout

ts <- DT[v,]
\end_layout

\begin_layout Plain Layout

meanDh16 <- mean(ts$herr)
\end_layout

\begin_layout Plain Layout

# plotWAC(ts[, c("Time", "herr"), ], ylab=expression(paste(delta,psi)))
\end_layout

\begin_layout Plain Layout

bf <- signal::butter(3,1/300)
\end_layout

\begin_layout Plain Layout

D1$hs <- rep(meanDh16, nrow(D1))
\end_layout

\begin_layout Plain Layout

for (i in 1:nrow(ts)) {
\end_layout

\begin_layout Plain Layout

  ix <- which(D1$Time == ts$Time[i])
\end_layout

\begin_layout Plain Layout

  D1$hs[ix] <- ts$herr[i]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

hs <- zoo::na.approx (as.vector(D1$hs), maxgap=3000, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

hs <- signal::filtfilt(bf, hs)
\end_layout

\begin_layout Plain Layout

lineWAC(D1$Time, hs, col='red')
\end_layout

\begin_layout Plain Layout

legend('topright', legend=expression(paste("smoothed ",delta,psi)), col='red',
\end_layout

\begin_layout Plain Layout

       text.col='red', lwd=2, lty=1, bg='lightyellow')
\end_layout

\begin_layout Plain Layout

sdDh16 <- sd(hs, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<spline-plot, include=TRUE, fig.height=4, fig.cap="Estimates of heading errors
 arising from turns during DEEPWAVE flight 16 (4 July 2014).
 Estimates from each left and right turn are plotted separately, and two
 spline fits with different degrees of smoothing are shown.
 Error bars are approximately $2
\backslash

\backslash
sigma_m$ where $
\backslash

\backslash
sigma_m$ is the standard deviation in the mean value.">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

formatTime <- function (time) {
\end_layout

\begin_layout Plain Layout

  t <- as.POSIXlt (time)
\end_layout

\begin_layout Plain Layout

  tt <- sprintf ("%d:%02d:%02d", t$hour, t$min, t$sec)
\end_layout

\begin_layout Plain Layout

  return (tt)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT$TestR <- (!is.na(DT$Time) & (DT$ROLL > 10))
\end_layout

\begin_layout Plain Layout

DT$TestL <- (!is.na(DT$Time) & (DT$ROLL < -10))
\end_layout

\begin_layout Plain Layout

DSET <- data.frame ()
\end_layout

\begin_layout Plain Layout

set <- vector("numeric")
\end_layout

\begin_layout Plain Layout

hmean <- vector("numeric")
\end_layout

\begin_layout Plain Layout

hsd <- vector("numeric")
\end_layout

\begin_layout Plain Layout

tbar <- vector("numeric")
\end_layout

\begin_layout Plain Layout

hmeanR <- vector("numeric")
\end_layout

\begin_layout Plain Layout

hsdR <- vector("numeric")
\end_layout

\begin_layout Plain Layout

tbarR <- vector("numeric")
\end_layout

\begin_layout Plain Layout

hmeanL <- vector("numeric")
\end_layout

\begin_layout Plain Layout

hsdL <- vector("numeric")
\end_layout

\begin_layout Plain Layout

tbarL <- vector("numeric")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

setStart <- 0
\end_layout

\begin_layout Plain Layout

NRA <- 40
\end_layout

\begin_layout Plain Layout

for (k in 1:nrow(DT)) {
\end_layout

\begin_layout Plain Layout

  if (DT$TestR[k] || DT$TestL[k]) {
\end_layout

\begin_layout Plain Layout

    if (setStart == 0) {
\end_layout

\begin_layout Plain Layout

      setStart <- k
\end_layout

\begin_layout Plain Layout

      setEnd <- k
\end_layout

\begin_layout Plain Layout

      DSET <- rbind(DSET, DT[k,])
\end_layout

\begin_layout Plain Layout

    } else if (as.numeric(difftime(DT$Time[k], DT$Time[setEnd], units='sec'))
 > 300) {
\end_layout

\begin_layout Plain Layout

      if (length(DSET[DSET$TestR == TRUE, "herr"]) > 50 &&
\end_layout

\begin_layout Plain Layout

          length(DSET[DSET$TestL == TRUE, "herr"]) > 50) {      
\end_layout

\begin_layout Plain Layout

        hmnR <- mean (DSET$herr[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

        hmnL <- mean (DSET$herr[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

        hsdevR <- sd (DSET$herr[DSET$TestR], na.rm=TRUE) / 
\end_layout

\begin_layout Plain Layout

                      sqrt (length (DSET$TestR)/NRA)
\end_layout

\begin_layout Plain Layout

        hsdevL <- sd (DSET$herr[DSET$TestL], na.rm=TRUE) / 
\end_layout

\begin_layout Plain Layout

                     sqrt (length (DSET$TestL)/NRA)
\end_layout

\begin_layout Plain Layout

        tbrR <- mean(DSET$Time[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

        tbrL <- mean(DSET$Time[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

       # print (sprintf ("R time %s count %d", as.POSIXct (tbrR, origin="2014-07-
04", tz="GMT"), length(DSET$TestR)))
\end_layout

\begin_layout Plain Layout

        hmeanR <- c(hmeanR, hmnR)
\end_layout

\begin_layout Plain Layout

        hsdR   <- c(hsdR, hsdevR)
\end_layout

\begin_layout Plain Layout

        tbarR  <- c(tbarR, tbrR)
\end_layout

\begin_layout Plain Layout

       # print (sprintf ("L time %s count %d", as.POSIXct (tbrL, origin="2014-07-
04", tz="GMT"), length(DSET$TestL)))
\end_layout

\begin_layout Plain Layout

        hmeanL <- c(hmeanL, hmnL)
\end_layout

\begin_layout Plain Layout

        hsdL   <- c(hsdL, hsdevL)
\end_layout

\begin_layout Plain Layout

        tbarL  <- c(tbarL, tbrL)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      setStart <- k
\end_layout

\begin_layout Plain Layout

      setEnd <- k
\end_layout

\begin_layout Plain Layout

      DSET <- DT[k,]
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

      setEnd <- k
\end_layout

\begin_layout Plain Layout

      DSET <- rbind(DSET, DT[k,])
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

if (nrow(DSET) > 100) {
\end_layout

\begin_layout Plain Layout

  hmnR <- mean (DSET$herr[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  hmnL <- mean (DSET$herr[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  hsdevR <- sd (DSET$herr[DSET$TestR], na.rm=TRUE) / sqrt (length (DSET$TestR)/NR
A)
\end_layout

\begin_layout Plain Layout

  hsdevL <- sd (DSET$herr[DSET$TestL], na.rm=TRUE) / sqrt (length (DSET$TestL)/NR
A)
\end_layout

\begin_layout Plain Layout

  tbrR <- mean(DSET$Time[DSET$TestR], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  tbrL <- mean(DSET$Time[DSET$TestL], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  if (length(DSET[DSET$TestR == TRUE, "herr"]) > 50 &&
\end_layout

\begin_layout Plain Layout

      length(DSET[DSET$TestL == TRUE, "herr"]) > 50) {
\end_layout

\begin_layout Plain Layout

    hmeanR <- c(hmeanR, hmnR)
\end_layout

\begin_layout Plain Layout

    hsdR   <- c(hsdR, hsdevR)
\end_layout

\begin_layout Plain Layout

    tbarR  <- c(tbarR, tbrR)
\end_layout

\begin_layout Plain Layout

    hmeanL <- c(hmeanL, hmnL)
\end_layout

\begin_layout Plain Layout

    hsdL   <- c(hsdL, hsdevL)
\end_layout

\begin_layout Plain Layout

    tbarL  <- c(tbarL, tbrL)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

clr <- c("right", "left", "spline")
\end_layout

\begin_layout Plain Layout

col <- c ('blue', 'darkgreen', "red")
\end_layout

\begin_layout Plain Layout

EH <- data.frame(tbar=c(tbarL, tbarR), hmeanR=c(rep(NA, length(tbarL)), hmeanR),
 hmeanL=c(hmeanL, rep(NA, length(tbarR))), hsdR=c(rep(NA, length(tbarL)),
 hsdR), hsdL=c(hsdL, rep(NA, length(tbarR))))
\end_layout

\begin_layout Plain Layout

EH$tbar <- as.POSIXct (EH$tbar, origin="1970-01-01", tz="GMT")
\end_layout

\begin_layout Plain Layout

whmean <- weighted.mean (c(EH$hmeanR, EH$hmeanL), 
\end_layout

\begin_layout Plain Layout

                         c(1/EH$hsdR^2, 1/EH$hsdL^2), na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

whsd <- sqrt (1/sum(c(1/EH$hsdR^2, 1/EH$hsdL^2), na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

p <- ggplot(EH, aes(x=tbar), na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

p <- p + geom_errorbar(aes(ymin=hmeanR-hsdR, ymax=hmeanR+hsdR, colour=clr[1]),
\end_layout

\begin_layout Plain Layout

                       width=600, size=1.5, na.rm=TRUE) + ylim (-0.25,0.15)
\end_layout

\begin_layout Plain Layout

p <- p + geom_point (aes(y = hmeanR, colour=clr[1]),size=3.5, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

p <- p + geom_errorbar(aes(ymin=hmeanL-hsdL, ymax=hmeanL+hsdL, colour=clr[2]),
\end_layout

\begin_layout Plain Layout

                       width=600, size=1.5, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

p <- p + geom_point (aes(y = hmeanL, colour=clr[2]), size=3.5, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

p <- p + ylab(expression(paste(delta,psi,' [',degree,']')))
\end_layout

\begin_layout Plain Layout

p <- p + xlab ("Time [UTC]")
\end_layout

\begin_layout Plain Layout

yss <- c(EH$hmeanL[!is.na(EH$hmeanL)], EH$hmeanR[!is.na(EH$hmeanR)])
\end_layout

\begin_layout Plain Layout

SS <- smooth.spline(EH$tbar, yss, df=8, spar=0.7)
\end_layout

\begin_layout Plain Layout

# xss <- as.POSIXct (SS$x, origin="1970-01-01", tz="GMT")
\end_layout

\begin_layout Plain Layout

# p <- p + geom_line(aes(x=xss, y=SS$y, colour=clr[3]), lwd=2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

D1$HC <- predict(SS, as.numeric(D1$Time))$y
\end_layout

\begin_layout Plain Layout

p <- p + geom_line (data=D1, aes (x=Time, y=HC, colour=clr[3]), lwd=2, na.rm=TRUE
)
\end_layout

\begin_layout Plain Layout

SS2 <- smooth.spline(EH$tbar, yss, df=8, spar=0.4)
\end_layout

\begin_layout Plain Layout

xss2 <- as.POSIXct (SS2$x, origin="1970-01-01", tz="GMT")
\end_layout

\begin_layout Plain Layout

p <- p + geom_line(aes(x=xss2, y=SS2$y, colour=clr[3]), lwd=2, lty=2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

cols <- c("right"="blue", "left"="darkgreen", "spline"="red")
\end_layout

\begin_layout Plain Layout

p <- p + scale_colour_manual("turn direction:", values=cols)
\end_layout

\begin_layout Plain Layout

p <- p + guides(color=guide_legend(override.aes=list(shape=c(16,16,NA), 
\end_layout

\begin_layout Plain Layout

                                                     linetype=c(0,0,1))))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

p <- p + theme_WAC()
\end_layout

\begin_layout Plain Layout

print (p)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

<<construct-HR-correction>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## construct the high-rate heading correction HC
\end_layout

\begin_layout Plain Layout

D$HC <- predict(SS, as.numeric(D$Time))$y
\end_layout

\begin_layout Plain Layout

DSAVE <- D    # save for use in later section
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Flight 16 from the DEEPWAVE project was a more typical research flight,
 in which repeated passes were flown over the mountainous terrain of New
 Zealand.
 Legs of typically about 45 min duration started and ended with turns that
 usually reversed course and so provided good accelerations for correcting
 the measurement of heading.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:spline-plot}
\end_layout

\end_inset

 shows the deduced heading errors for this flight.
 The weighted mean error was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(whmean,2)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

 and the standard deviation in the weighted mean error was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(whsd, 2)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

, so this indicates that for this flight the mean correction was close to
 that for flight 15.
 The standard deviation represents a low uncertainty that, translated to
 the lateral component of the horizontal wind, would amount to an uncertainty
 of about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(whsd*220*pi/180, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 This uncertainty is small in comparison to other contributions, as discussed
 more extensively in the Appendix.
 
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Subsection
Details regarding the correction algorithm
\end_layout

\begin_layout Plain Layout

\emph on
[maybe move this to an appendix?]
\end_layout

\begin_layout Plain Layout
The intent of this section is to provide an algorithm suitable for routine
 use.
 The requirements for this algorithm are as follows:
\end_layout

\begin_layout Itemize
The flight pattern must include maneuvers that provide horizontal accelerations,
 usually turns of at least 30
\begin_inset space \thinspace{}
\end_inset

s duration 
\emph on
in each direction.

\emph default
 The reason is that it is difficult to correct for timing errors in the
 measurements of heading relative to the measured ground-speed components
 from a GPS receiver, and even a delay of 50
\begin_inset space \thinspace{}
\end_inset

ms will, for a turn rate corresponding to a three-minute turn through 360
\begin_inset Formula $^{\circ}$
\end_inset

, lead to a 0.05
\begin_inset Formula $^{\circ}$
\end_inset

 false indication of a heading error.
 However, the error reverses sign with the direction of the turn, so averaging
 the results from left turns and from right turns will correct for this
 false indication of a heading error.
 Course-reversal maneuvers like 
\begin_inset Quotes eld
\end_inset

90-270
\begin_inset Quotes erd
\end_inset

 turns (90
\begin_inset Formula $^{\circ}$
\end_inset

 one direction followed by 270
\begin_inset Formula $^{\circ}$
\end_inset

 the other direction) provide good data for this algorithm, as do 
\begin_inset Quotes eld
\end_inset

60-300-60
\begin_inset Quotes erd
\end_inset

 teardrop turns that are a faster means of returning to the starting point.
 If wind measurements are critical to the research, it may be useful to
 include patterns like 
\begin_inset Quotes eld
\end_inset

S
\begin_inset Quotes erd
\end_inset

 turns periodically, with 30
\begin_inset space \thinspace{}
\end_inset

s turns in opposite directions, to provide the needed accelerations.
\end_layout

\begin_layout Itemize
To the extent possible, sampled time series should be corrected for sampling
 delays.
 The most important such correction is the timing of the heading measurements
 from the INS relative to the ground-speed measurements from the GPS.
 In the examples shown in this note, the differences between different turn
 directions were minimized by shifting the heading forward in time by 140
 ms, so this shift was applied before calculations such as those shown in
 Figs.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:spline-plot}
\end_layout

\end_inset

 or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:errors-rf16}
\end_layout

\end_inset

.
 The averaging provided by the first item above helps reduce errors from
 timing, but it is still preferable to keep those errors small.
 Circle maneuvers such as used to construct Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:errors-rf16}
\end_layout

\end_inset

 provide a sensitive test of timing errors.
\end_layout

\begin_layout Plain Layout
Many research flights and research data sets meet these requirements, and
 they can be addressed in flight plans for future projects.
 The algorithm implemented here, for which specific R code is available,
 follows these steps:
\end_layout

\begin_layout Enumerate

\emph on
Shift the heading measurement as needed, where necessary using fractional
 increments in the time series.

\emph default
 For example, the standard high-rate data sets provided by the NCAR/EOL/RAF
 data processing are 25
\begin_inset space \thinspace{}
\end_inset

Hz time series, so a shift of 140
\begin_inset space \thinspace{}
\end_inset

ms represents a 3.5-increment.
 This can be accomplished using interpolation to higher-rate series, filtering
 of the high-rate file, and resampling at the original rate.
\end_layout

\begin_layout Enumerate

\emph on
For data files produced at rates above 1
\begin_inset space \thinspace{}
\end_inset

Hz, construct a 1
\begin_inset space \thinspace{}
\end_inset

Hz data set to use when calculating the heading correction.

\emph default
 These results change only slowly, as suggested in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:spline-plot}
\end_layout

\end_inset

 Because the application of the transformations, differentiations, and pitch
 corrections require considerable calculation, this results in considerably
 faster calculations.
 
\end_layout

\begin_layout Enumerate

\emph on
Apply the pitch and roll corrections using the algorithm developed in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Correcting-the-pitch"

\end_inset

.
 
\emph default
The measurements of pitch and, to a lesser extent, roll affect the transformatio
n of the accelerations from the 
\begin_inset Formula $a$
\end_inset

-frame to the 
\begin_inset Formula $l$
\end_inset

-frame.
 Although the correction developed here depends only weakly on the correction
 to pitch and roll, inclusion of this step may protect against or at least
 identify anomalously large errors in pitch.
 Reciprocally, the pitch correction depends on the measured heading, but
 the effect of heading errors are insignificant.
 Omission of this step normally makes no detectable difference.
\end_layout

\begin_layout Enumerate

\emph on
Differentiate the ground-speed measurements provided by a GPS receiver,
\emph default
 using Savitzky-Golay polynomials, to obtain reference measurements of horizonta
l accelerations in the 
\begin_inset Formula $l$
\end_inset

-frame.
 The specific choice was to use third-order polynomials spanning 21
\begin_inset space \thinspace{}
\end_inset

s.
\end_layout

\begin_layout Enumerate

\emph on
Transform the accelerations measured by the INS in the 
\begin_inset Formula $a$
\end_inset

-frame to the 
\begin_inset Formula $l$
\end_inset

-frame.

\emph default
 Filter these results also using Savitzky-Golay polynomials of the same
 order and span so that they are smoothed in the same way as the ground-speed
 derivatives.
\end_layout

\begin_layout Enumerate

\emph on
Use (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:final-answer"

\end_inset

) to obtain estimates of the heading error 
\begin_inset Formula $\delta\psi$
\end_inset

 at each time.

\emph default
 However, apply data restrictions to avoid cases of high uncertainty.
 The most important restriction used here was to require that the total
 horizontal acceleration in the 
\begin_inset Formula $l$
\end_inset

-frame be larger than 
\begin_inset Formula $1$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 
\end_layout

\begin_layout Enumerate

\emph on
Use a search algorithm to identify flight segments with turns
\emph default
 (specifically, magnitude of roll larger than 10
\begin_inset Formula $^{\circ}$
\end_inset

) continuously except for possible gaps of 5
\begin_inset space \thinspace{}
\end_inset

min.
 Require that these flight segments have both right and left turns, with
 at least 45
\begin_inset space \thinspace{}
\end_inset

s of each.
\end_layout

\begin_layout Enumerate

\emph on
For each such segment, calculate the mean correction
\emph default
 and its standard deviation and the mean time for each turn direction.
\end_layout

\begin_layout Enumerate

\emph on
Use cubic spline interpolation
\emph default
 to represent the variation in heading correction over the course of the
 flight.
 Two possible choices are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:spline-plot}
\end_layout

\end_inset

; of these, the smoother choice is incorporated into the algorithm.
\end_layout

\begin_layout Enumerate

\emph on
Subtract the result given by the interopolation from the measured heading.
\end_layout

\begin_layout Plain Layout
The archives accompanying this note include specific algorithms for each
 step and a complete program constructing this text as well as performing
 the data-analysis steps.
 In particular, there are functions for the pitch correction and heading
 correction, for time-shifting, and for transformations between reference
 frames.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Section

\lang english
Comparison to an IRS with a Kalman filter
\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout

<<prelim>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

require(xts)
\end_layout

\begin_layout Plain Layout

require(zoo)
\end_layout

\begin_layout Plain Layout

require(signal)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

transferAttributes <- function (dsub, d) {
\end_layout

\begin_layout Plain Layout

  ds <- dsub
\end_layout

\begin_layout Plain Layout

  for (nm in names (ds)) {
\end_layout

\begin_layout Plain Layout

    if (nm %in% names(d)) {
\end_layout

\begin_layout Plain Layout

      var <- sprintf ("d$%s", nm)
\end_layout

\begin_layout Plain Layout

      A <- attributes (eval (parse (text=var)))
\end_layout

\begin_layout Plain Layout

      A$dim <- NULL
\end_layout

\begin_layout Plain Layout

      if (nm != "Time") {
\end_layout

\begin_layout Plain Layout

        A$class <- NULL
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      attributes (ds[,nm]) <- A
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  return(ds)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<read-applanix, echo=TRUE, include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

SaveRData5 <- sprintf("%s5.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  ApplanixRF16 <- read.table ("/Data/DEEPWAVE/ApplanixRF16.txt", 
\end_layout

\begin_layout Plain Layout

                            header=TRUE, quote="
\backslash
"", stringsAsFactors=FALSE)
\end_layout

\begin_layout Plain Layout

  ## convert times to a POSIX-format time, for merging with standard netCDF:
\end_layout

\begin_layout Plain Layout

  ## (note 2014-07-04 is the flight date)
\end_layout

\begin_layout Plain Layout

  ApplanixRF16$Time <- as.POSIXct (ApplanixRF16$time_.UTC_seconds_of_day.,
\end_layout

\begin_layout Plain Layout

                                 origin="2014-07-04", tz="GMT")
\end_layout

\begin_layout Plain Layout

  NewNames <- names (ApplanixRF16)
\end_layout

\begin_layout Plain Layout

  ## reassign names as specified in file NewNames:
\end_layout

\begin_layout Plain Layout

  source ('NewNames')
\end_layout

\begin_layout Plain Layout

  NewNames <- c(NewNames, "Time")
\end_layout

\begin_layout Plain Layout

  names (ApplanixRF16) <- NewNames
\end_layout

\begin_layout Plain Layout

  save(ApplanixRF16, file=SaveRData5)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load(SaveRData5)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

<<read-HRT-netCDF, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## read variables from netCDF file, including those needed for pitch correction:
\end_layout

\begin_layout Plain Layout

# Flight <- "rf16h"
\end_layout

\begin_layout Plain Layout

# # Data <- getNetCDF ("/scr/raf/Prod_Data/DEEPWAVE/HRT/DEEPWAVErf16hPC.nc",
\end_layout

\begin_layout Plain Layout

# Data <- getNetCDF ("/Data/DEEPWAVE/DEEPWAVErf16h.nc",
\end_layout

\begin_layout Plain Layout

#                    standardVariables(c("PITCH", "ROLL", "THDG", "GGVSPD",
\end_layout

\begin_layout Plain Layout

#                                        "VNS", "VEW", "GGVNS", "GGVEW",
 "LATC")))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Rate <- 1
\end_layout

\begin_layout Plain Layout

# if ("sps25" %in% names(attributes(Data)$Dimensions)) {Rate <- 25}
\end_layout

\begin_layout Plain Layout

# s <- -60
\end_layout

\begin_layout Plain Layout

# Data$VEW <- ShiftInTime (Data$VEW, Rate, s)
\end_layout

\begin_layout Plain Layout

# Data$VNS <- ShiftInTime (Data$VNS, Rate, s)
\end_layout

\begin_layout Plain Layout

# Data$THDG <- ShiftInTime (Data$THDG, Rate, s)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# C <- CorrectPitch(Data)
\end_layout

\begin_layout Plain Layout

# Data$PITCHC <- Data$PITCH - C[,1] 
\end_layout

\begin_layout Plain Layout

# Data$ROLLC <- Data$ROLL - C[,2]
\end_layout

\begin_layout Plain Layout

Data <- DataSave
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

if ("sps25" %in% names(attributes(Data)$Dimensions)) {Rate <- 25}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## if Rate > 10, need to interpolate/filter the 10-Hz Applanix measurements
 to get 25 Hz;
\end_layout

\begin_layout Plain Layout

## if Rate == 1, need to average the 10-Hz Applanix measurements
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ReloadDave <- FALSE
\end_layout

\begin_layout Plain Layout

ReloadDave <- TRUE
\end_layout

\begin_layout Plain Layout

if (ReloadDave) {
\end_layout

\begin_layout Plain Layout

  if (Rate == 25) {
\end_layout

\begin_layout Plain Layout

    L <- 2.5 * nrow (ApplanixRF16)
\end_layout

\begin_layout Plain Layout

    for (nm in names (ApplanixRF16)) {
\end_layout

\begin_layout Plain Layout

      if (nm == "Time") {next}    ## skip Time; will handle specially below
\end_layout

\begin_layout Plain Layout

      ## angle variables require vector averaging to avoid wrap-around problems
\end_layout

\begin_layout Plain Layout

      if (nm == "THDG_APPX" || nm == "WANDER_APPX" || nm == "HDG_APPX")
 {
\end_layout

\begin_layout Plain Layout

        sina <- sin (ApplanixRF16[, nm] * pi/180)
\end_layout

\begin_layout Plain Layout

        cosa <- cos (ApplanixRF16[, nm] * pi/180)
\end_layout

\begin_layout Plain Layout

        X1 <- stats::approx (x=ApplanixRF16$time_seconds_APPX, y=sina,
\end_layout

\begin_layout Plain Layout

                            method='linear', n=L)
\end_layout

\begin_layout Plain Layout

        X2 <- stats::approx (x=ApplanixRF16$time_seconds_APPX, y=cosa,
\end_layout

\begin_layout Plain Layout

                             method='linear', n=L)
\end_layout

\begin_layout Plain Layout

        ## apply small amount of filtering to linearly interpolated values
\end_layout

\begin_layout Plain Layout

        X1$y <- signal::filter (signal::sgolay(3,7), X1$y)
\end_layout

\begin_layout Plain Layout

        X2$y <- signal::filter (signal::sgolay(3,7), X2$y)
\end_layout

\begin_layout Plain Layout

        Dave[, nm] <- (atan2(X1$y, X2$y) * 180/pi + 360) %% 360
\end_layout

\begin_layout Plain Layout

      } else {    ## these are now not-angle variables
\end_layout

\begin_layout Plain Layout

        X <- stats::approx (x=ApplanixRF16$time_seconds_APPX, y=ApplanixRF16[,
 nm], 
\end_layout

\begin_layout Plain Layout

                           method='linear', n=L)
\end_layout

\begin_layout Plain Layout

        X$y <- signal::filter (signal::sgolay (3,7), X$y)
\end_layout

\begin_layout Plain Layout

        ## add variables to data.frame
\end_layout

\begin_layout Plain Layout

        if (grepl("time", nm)) {
\end_layout

\begin_layout Plain Layout

          Dave <- data.frame(time_seconds_APPX=X$y)
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

          Dave[, nm] <- X$y
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  } else {  ## this is branch for 1-Hz data
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    ## construct 1-Hz data by averaging 10-Hz data    
\end_layout

\begin_layout Plain Layout

    ep <- endpoints(ApplanixRF16$Time, 'seconds')
\end_layout

\begin_layout Plain Layout

    tt <- as.integer(period.apply(ApplanixRF16$time_seconds_APPX, ep, mean))
\end_layout

\begin_layout Plain Layout

    Dave <- data.frame(time_seconds_APPX=tt)
\end_layout

\begin_layout Plain Layout

    for (nm in names(ApplanixRF16)) {
\end_layout

\begin_layout Plain Layout

      print(nm)
\end_layout

\begin_layout Plain Layout

      if (nm == "Time") {next}
\end_layout

\begin_layout Plain Layout

      ## deal specially with THDG_APPX to handle wrap-around
\end_layout

\begin_layout Plain Layout

      if (nm == "THDG_APPX" || nm == "WANDER_APPX" || nm == "HDG_APPX")
 {
\end_layout

\begin_layout Plain Layout

        ## note that this is the preferred way to average angles
\end_layout

\begin_layout Plain Layout

        sina <- sin(ApplanixRF16[, nm] * pi/180)
\end_layout

\begin_layout Plain Layout

        cosa <- cos(ApplanixRF16[, nm] * pi/180)
\end_layout

\begin_layout Plain Layout

        sinave <- period.apply(sina, ep, mean)
\end_layout

\begin_layout Plain Layout

        cosave <- period.apply(cosa, ep, mean)
\end_layout

\begin_layout Plain Layout

        Dave[, nm] <- (atan2(sinave, cosave)*180/pi + 360) %% 360
\end_layout

\begin_layout Plain Layout

      } else {
\end_layout

\begin_layout Plain Layout

        if (grepl("time_s", nm)) {next}  ## already dealt with time_s
\end_layout

\begin_layout Plain Layout

        Dave[, nm] <- period.apply(ApplanixRF16[,nm], ep, mean)
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Dave$Time <- as.POSIXct(Dave$time_seconds_APPX, origin="2014-07-04", tz="GMT")
\end_layout

\begin_layout Plain Layout

  save(Dave, file="APPX.Rdata")
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load(file='APPX.Rdata')
\end_layout

\begin_layout Plain Layout

}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout

<<match-times, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  ## now set consistent time limits and dimensions in the two files
\end_layout

\begin_layout Plain Layout

  ## The netCDF file is a subset of the Applanix file, so truncate the latter
\end_layout

\begin_layout Plain Layout

SE <- getStartEnd(Data$Time)
\end_layout

\begin_layout Plain Layout

r <- setRange(Dave$Time, SE[1], SE[2])
\end_layout

\begin_layout Plain Layout

Dave <- Dave[r, ]
\end_layout

\begin_layout Plain Layout

## need work here: match times
\end_layout

\begin_layout Plain Layout

## make sure they match:
\end_layout

\begin_layout Plain Layout

DVE <- Dave
\end_layout

\begin_layout Plain Layout

for (i in 1:nrow(Data)) {
\end_layout

\begin_layout Plain Layout

  DVE[i,] <- NULL
\end_layout

\begin_layout Plain Layout

  j <- which (abs(Dave$Time-Data$Time[i]) < 0.02)
\end_layout

\begin_layout Plain Layout

  if (length(j) > 1) {printf (sprintf ("multiple matches i=%d j=%d %d",
 i, j[1], j[2]))}
\end_layout

\begin_layout Plain Layout

  if (j == NA || j == 0) {print (sprintf ("no match for i=%d", i))}
\end_layout

\begin_layout Plain Layout

  DVE[i,] <- DAVE[j,]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DAVE <- DVE
\end_layout

\begin_layout Plain Layout

DS <- Data
\end_layout

\begin_layout Plain Layout

Data <- Data[1:nrow(Dave),]
\end_layout

\begin_layout Plain Layout

Data <- transferAttributes(Data, DS)
\end_layout

\begin_layout Plain Layout

Dave$Time <- NULL    ## this is a duplicate
\end_layout

\begin_layout Plain Layout

Dave <- cbind(Data, Dave)  ## merge the two data.files
\end_layout

\begin_layout Plain Layout

attributes(Dave) <- attributes(Data)
\end_layout

\begin_layout Plain Layout

NewNames <- NewNames[-which(NewNames == 'Time')]  ## eliminate Time for
 NewNames
\end_layout

\begin_layout Plain Layout

names (Dave) <- c(names (Data), NewNames)
\end_layout

\begin_layout Plain Layout

Dave <- transferAttributes (Dave, DS)             ## DS is saved 'Data'
\end_layout

\begin_layout Plain Layout

Dave$DTHDG <- Dave$THDG-Dave$THDG_APPX
\end_layout

\begin_layout Plain Layout

Dave$DTHDG[Dave$DTHDG > 180] <- Dave$DTHDG[Dave$DTHDG > 180] - 360
\end_layout

\begin_layout Plain Layout

Dave$DTHDG[Dave$DTHDG < -180] <- Dave$DTHDG[Dave$DTHDG < -180] + 360
\end_layout

\begin_layout Plain Layout

Dave$DPITCH <- Dave$PITCH-Dave$PITCH_APPX
\end_layout

\begin_layout Plain Layout

Dave$DPITCHC <- Dave$PITCHC-Dave$PITCH_APPX
\end_layout

\begin_layout Plain Layout

Dave$DROLL <- Dave$ROLL - Dave$ROLL_APPX
\end_layout

\begin_layout Plain Layout

Dave$DROLLC <- Dave$ROLLC-Dave$ROLL_APPX
\end_layout

\begin_layout Plain Layout

SE <- getStartEnd(Dave$Time)
\end_layout

\begin_layout Plain Layout

r <- setRange(Dave$Time, SE[1], SE[2])
\end_layout

\begin_layout Plain Layout

DT <- Dave[r, ]
\end_layout

\begin_layout Plain Layout

q <- (abs(DT$ROLL) > 5) | (DT$TASX < 130)
\end_layout

\begin_layout Plain Layout

DT$DROLL[q] <- NA
\end_layout

\begin_layout Plain Layout

DT$DPITCH[q] <- NA
\end_layout

\begin_layout Plain Layout

DT$DTHDG[q] <- NA
\end_layout

\begin_layout Plain Layout

DT$DPITCHC[q] <- NA
\end_layout

\begin_layout Plain Layout

mP <- mean(DT$PITCH, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

mPC <- mean(DT$PITCHC, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

mPA <- mean(DT$PITCH_APPX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DT$DP <- DT$DPITCH - mP + mPA
\end_layout

\begin_layout Plain Layout

DT$DPC <- DT$DPITCHC - mPC + mPA
\end_layout

\begin_layout Plain Layout

mR <- mean(DT$ROLL, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

mRC <- mean(DT$ROLLC, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

mRA <- mean(DT$ROLL_APPX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DT$DR <- DT$DROLL - mR + mRA
\end_layout

\begin_layout Plain Layout

DT$DRC <- DT$DROLLC - mRC + mRA
\end_layout

\begin_layout Plain Layout

DT$PC <- DT$PITCHC - DT$PITCH
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Some properties of the corrections
\end_layout

\begin_layout Subsection
The pitch correction
\end_layout

\begin_layout Subsubsection
Typical magnitudes
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<typical-errors, include=TRUE, fig.height=4, fig.cap="Probability distribution
 of individual 1-Hz estimate of the pitch error as determined using the
 algorithm of Sect.2.">>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Project <- "DEEPWAVE"
\end_layout

\begin_layout Plain Layout

Flight <- "rf16"
\end_layout

\begin_layout Plain Layout

DD <- getNetCDF (sprintf ("%s%s/%s%s.nc", DataDirectory(), Project, Project,
 Flight),
\end_layout

\begin_layout Plain Layout

                 c("PITCH", "ROLL", "THDG", "TASX", "VNS", "VEW", "GGVNS",
 "GGVEW",
\end_layout

\begin_layout Plain Layout

                   "LATC", "GGALT"))
\end_layout

\begin_layout Plain Layout

DD$PC <- CorrectPitch (DD)[,1]
\end_layout

\begin_layout Plain Layout

# hist(DD$PC, breaks=50, xlim=c(-0.05, 0.05), freq=FALSE, main=NULL)
\end_layout

\begin_layout Plain Layout

r <- (abs(DD$ROLL) < 5) & (DD$TASX > 130)
\end_layout

\begin_layout Plain Layout

ggplot (data=DD[r,], aes(x=PC)) +geom_density(fill='lightgrey')+xlim(-0.03,
 0.03)+xlab(expression(paste("estimated pitch error [", degree, "]")))+theme_WAC(
)
\end_layout

\begin_layout Plain Layout

meanPC <- mean(DD[r, "PC"], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

sdPC <- sd(DD[r, "PC"], na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As applied to most research flights, the corrections are fairly small.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:typical-errors}
\end_layout

\end_inset

 shows the density distribution of corrections calculated for one flight,
 filght 16 of the DEEPWAVE project.
 The standard deviation of the calculated corrections to pitch is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdPC, 2)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

, which would propagate to a standard error in measurements of vertical
 wind of about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdPC*Cradeg*220, 2)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

, and this is typical of most research flights examined including all but
 two of the 26 flights from the DEEPWAVE project.
 This is evidence that the measurement of pitch introduces little uncertainty
 into the measured vertical wind.
 Without this result, the instrument specification (0.05
\begin_inset Formula $^{\circ}$
\end_inset

) would be the estimated uncertainty in pitch, so the uncertainty in vertical
 wind is reduced significantly by this algorithm even if the correction
 is not applied.
 
\end_layout

\begin_layout Subsubsection
Reverse-heading legs
\end_layout

\begin_layout Standard
If the pitch correction reduces the error in pitch, wind measurements made
 before and after level course reversal would be expected to match better
 after correction because, if there is a pitch error, its contribution to
 the vertical wind would reverse sign between the two legs.
 The following is a tabulation of four instances where the flight track
 reversed course and remained at the same altitude.
 Some other candidates were excluded because conditions were too variable
 along the legs to produce a small-uncertainty estimate of the vertical
 wind, or because (as was the normal case in these research flights) the
 flight level changed.
 For these selected cases, the sample standard deviation for the vertical
 wind was typically about 0.3
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset


\begin_inset Formula $^{-1}$
\end_inset

, so in a 5-min leg with typical autocorrelation among measurements of about
 10
\begin_inset space ~
\end_inset

s the uncertainty in the comparison of two such means is estimated to be
 around 0.08
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 In each of the five cases, flight periods of about 5 min (sometimes adjusted
 in cases of strong wind to give similar-spatial-length segments flown upwind
 and downwind) are listed before and after the turn, but excluding the turn,
 to represent approximately overlapping flight segments where it would be
 expected that the vertical wind would be the same.
 
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Flight segments before and after constant-altitude course reversal in relatively
 steady wind conditions.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Flight
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
before turn (UTC)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
after turn (UTC)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12:25:00--12:30:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12:37:00--12:43:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7:53:00--7:58:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8:05:00--8:10:00
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8:39:30--8:44:30
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8:51:30--8:56:30
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
21
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8:51:00--8:55:00
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9:03:00--9:07:30
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{minipage}[t]{1
\backslash
columnwidth}%
\end_layout

\begin_layout Plain Layout


\backslash
hskip1in%
\end_layout

\begin_layout Plain Layout


\backslash
begin{tabular}{|c|c|c|}
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout


\backslash
textbf{Flight} &
\end_layout

\begin_layout Plain Layout


\backslash
textbf{Times before turn [m/s]} &
\end_layout

\begin_layout Plain Layout


\backslash
textbf{Times after turn [m/s]}
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

2 &
\end_layout

\begin_layout Plain Layout

12:25:00--12:30:00 &
\end_layout

\begin_layout Plain Layout

12:37:00--12:43:00
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

10 &
\end_layout

\begin_layout Plain Layout

7:53:00--7:58:00 &
\end_layout

\begin_layout Plain Layout

8:05:00--8:10:00
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout

19 &
\end_layout

\begin_layout Plain Layout

8:39:30--8:44:30 &
\end_layout

\begin_layout Plain Layout

8:51:30--8:56:30
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout

21 &
\end_layout

\begin_layout Plain Layout

8:51:00--8:55:00 &
\end_layout

\begin_layout Plain Layout

9:03:00--9:07:30
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout


\backslash
hline 
\end_layout

\begin_layout Plain Layout

% 21 &
\end_layout

\begin_layout Plain Layout

% 9:56:30--10:01:30 &
\end_layout

\begin_layout Plain Layout

% 10:08:00--10:13:00
\backslash
tabularnewline
\end_layout

\begin_layout Plain Layout

% 
\backslash
hline 
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}%
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout

% The average absolute value of the
\end_layout

\begin_layout Plain Layout

% difference before correction was smaller than 0.1
\backslash
,m/s, so the wind 
\end_layout

\begin_layout Plain Layout

% measurements were already in very good agreement for these pairs of legs
\end_layout

\begin_layout Plain Layout

% and not much improvement could be expected.
 
\end_layout

\begin_layout Plain Layout

% However, application of the
\end_layout

\begin_layout Plain Layout

% pitch-correction algorithm did reduce this average to about 36
\backslash
% of the
\end_layout

\begin_layout Plain Layout

% uncorrected value, as shown in Fig.
\backslash
 
\backslash
ref{fig:reverse-course-w-comparison}.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reverse-course-w-comparison, fig.height=3.5, fig.cap="Absolute difference
 in vertical wind for flight segments before and after level course-reversal
 maneuvers.
 The top panel shows the uncorrected measurements and the bottom panel shows
 the result of applying the pitch correction developed in Sect.
\backslash

\backslash
 2.", include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ReverseW <- function (D, start1, end1, start2, end2) {
\end_layout

\begin_layout Plain Layout

  DD <- D[setRange (D$Time, start1, end1), ]
\end_layout

\begin_layout Plain Layout

  v1 <- mean (DD$WIC, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  p1 <- mean (DD$PITCH, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  DD <- D[setRange (D$Time, start2, end2), ]
\end_layout

\begin_layout Plain Layout

  v2 <- mean (DD$WIC, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  p2 <- mean (DD$PITCH, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

  return (c(v1-v2, p1-p2))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

RC <- c(1,81000,81500,82500,83000,
\end_layout

\begin_layout Plain Layout

        2, 122500, 123000, 123700, 124300,
\end_layout

\begin_layout Plain Layout

        10, 75300, 75800, 80500, 81000,
\end_layout

\begin_layout Plain Layout

        10, 100400, 100800, 101600, 102100,
\end_layout

\begin_layout Plain Layout

        10, 104500, 105000, 105700, 110200,
\end_layout

\begin_layout Plain Layout

        14, 101300, 101800, 102400, 102900,
\end_layout

\begin_layout Plain Layout

        14, 113700, 114200, 114830, 115330,
\end_layout

\begin_layout Plain Layout

        16, 94000, 94500, 95400, 95900,
\end_layout

\begin_layout Plain Layout

        19, 83930, 84430, 85130, 85630,
\end_layout

\begin_layout Plain Layout

        21, 85100, 85500, 90300, 90730,
\end_layout

\begin_layout Plain Layout

#         21, 95400, 95900, 100900, 101400,
\end_layout

\begin_layout Plain Layout

        21, 95630, 100130, 100800, 101300,
\end_layout

\begin_layout Plain Layout

        21, 102900, 103400, 104700, 105230,
\end_layout

\begin_layout Plain Layout

        21, 114600, 115100, 120400, 121000)
\end_layout

\begin_layout Plain Layout

# many of the above (4,5,6,7,8,12,13) removed because there was altitude
 change
\end_layout

\begin_layout Plain Layout

# RC <- c(1,81000,81500,82500,83000,  ## for this, GGQUAL indicates problems
 and
\end_layout

\begin_layout Plain Layout

#                                     ## error signals vary rapidly here;
 exclude
\end_layout

\begin_layout Plain Layout

# 2, 122500, 123000, 123700, 124300,
\end_layout

\begin_layout Plain Layout

# 19, 83930, 84430, 85130, 85630,
\end_layout

\begin_layout Plain Layout

# 21, 85100, 85500, 90300, 90730,
\end_layout

\begin_layout Plain Layout

# 21, 95430, 95930, 101000, 101500)  ## WIC sdev high for this test? (ca
 0.3)
\end_layout

\begin_layout Plain Layout

dim(RC) <- c(5, length(RC)/5)
\end_layout

\begin_layout Plain Layout

wid <-vector("numeric", 13)
\end_layout

\begin_layout Plain Layout

pid <-vector("numeric", 13)
\end_layout

\begin_layout Plain Layout

widc <-vector("numeric", 13)
\end_layout

\begin_layout Plain Layout

pidc <-vector("numeric", 13)
\end_layout

\begin_layout Plain Layout

rr <- 1:dim(RC)[2]
\end_layout

\begin_layout Plain Layout

DDF <- data.frame()
\end_layout

\begin_layout Plain Layout

# ReloadData <- TRUE
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  for (j in rr) {
\end_layout

\begin_layout Plain Layout

    fnm <- sprintf ("%s%s/%srf%02d.nc", DataDirectory (), Project, Project,
 RC[1,j])
\end_layout

\begin_layout Plain Layout

    df <- getNetCDF (fnm, c("VNS", "VEW", "GGVNS", "GGVEW", "WIC", "TASX",
\end_layout

\begin_layout Plain Layout

                            "LATC", "GGALT", "THDG", "PITCH", "ROLL"))
\end_layout

\begin_layout Plain Layout

    Ts <- -80
\end_layout

\begin_layout Plain Layout

    if (j == 3 || j == 11) {Ts <- -800}
\end_layout

\begin_layout Plain Layout

    df$VNS <- ShiftInTime (df$VNS, 1, Ts)
\end_layout

\begin_layout Plain Layout

    df$VEW <- ShiftInTime (df$VEW, 1, Ts)
\end_layout

\begin_layout Plain Layout

    Ts <- -60
\end_layout

\begin_layout Plain Layout

    df$THDG <- ShiftInTime (df$THDG, 1, Ts)
\end_layout

\begin_layout Plain Layout

    PC <- CorrectPitch (df, .span=1013)
\end_layout

\begin_layout Plain Layout

    df$PITCHC <- df$PITCH - PC[,1]
\end_layout

\begin_layout Plain Layout

    df$WIX <- df$WIC + df$TASX * PC[,1] * pi / 180
\end_layout

\begin_layout Plain Layout

    df <- df[setRange(df$Time, RC[2,j], RC[5,j]), ]
\end_layout

\begin_layout Plain Layout

    df$RF <- rep (j, nrow(df))
\end_layout

\begin_layout Plain Layout

    DDF <- rbind (DDF, df)
\end_layout

\begin_layout Plain Layout

  } 
\end_layout

\begin_layout Plain Layout

  save (DDF, file="DataFrames/SchulerdfAll.Rdata")
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file="DataFrames/SchulerdfAll.Rdata")
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for (j in rr) {
\end_layout

\begin_layout Plain Layout

  df <- DDF[DDF$RF == j,]
\end_layout

\begin_layout Plain Layout

  if (j == 1) {next}     ## GPS problems here
\end_layout

\begin_layout Plain Layout

  if (sd (df$GGALT, na.rm=TRUE) > 200) {
\end_layout

\begin_layout Plain Layout

    rr[j] <- NA
\end_layout

\begin_layout Plain Layout

    next
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  x <- ReverseW (df, RC[2,j], RC[3,j], RC[4,j], RC[5,j])
\end_layout

\begin_layout Plain Layout

  wid[j] <- x[1]
\end_layout

\begin_layout Plain Layout

  pid[j] <- x[2]
\end_layout

\begin_layout Plain Layout

  df$PITCH <- df$PITCHC 
\end_layout

\begin_layout Plain Layout

  df$WIC <- df$WIX
\end_layout

\begin_layout Plain Layout

  x <- ReverseW (df, RC[2,j], RC[3,j], RC[4,j], RC[5,j])
\end_layout

\begin_layout Plain Layout

  widc[j] <- x[1]
\end_layout

\begin_layout Plain Layout

  pidc[j] <- x[2]
\end_layout

\begin_layout Plain Layout

  # print (sprintf ("set %d %.3f %.3f %.3f %.3f", j, wid[j], pid[j], widc[j],
 pidc[j]))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

rr[1] <- NA
\end_layout

\begin_layout Plain Layout

rr[11] <- NA
\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol = 1), widths = 1, heights = c(5, 7))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

# op <- par (mfrow=c(2,1), mar=c(2,5,2,2)+0.1)
\end_layout

\begin_layout Plain Layout

hist (abs(wid[rr]), border='blue', col=rgb(0,0,100,30, maxColorValue=255),
 
\end_layout

\begin_layout Plain Layout

      breaks=20, angle=-45, xlim=c(0,0.2), 
\end_layout

\begin_layout Plain Layout

      xlab='absolute difference, uncorrected mean vertical wind [m/s]',
 main=NULL)
\end_layout

\begin_layout Plain Layout

legend('topright', legend='uncorrected', text.col='blue')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,2.5)+0.1)
\end_layout

\begin_layout Plain Layout

hist (abs(widc[rr]), border='red', col=rgb(100,0,0,30,maxColorValue=255),lwd=3,
 
\end_layout

\begin_layout Plain Layout

      breaks=20, xlim=c(0,0.2), xlab='absolute difference, mean vertical
 wind [m/s]', main=NULL)
\end_layout

\begin_layout Plain Layout

legend('topright', legend="after correction", text.col='red')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# print (sprintf ("mean uncorrected %f, corrected %f", mean(abs(wid[rr]),
 na.rm=TRUE), mean(abs(widc[rr]), na.rm=TRUE)))
\end_layout

\begin_layout Plain Layout

# print (wid)
\end_layout

\begin_layout Plain Layout

# print (widc)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The difference between average vertical wind measurements for each pair
 of legs was calculated before and after applying the pitch-correction algorithm
 developed in this subsection.
 The results are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:reverse-course-w-comparison}
\end_layout

\end_inset

.
 The measurements were in good agreement without any pitch correction, with
 an average absolute value of the difference between opposing legs of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(mean(abs(wid[rr]), na.rm=TRUE),2)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

, about comparable to the uncertainty estimate from natural variability
 as developed in the preceding paragraph.
 The pitch correction kept the averages quite small and improved the agreement,
 reducing the mean value of the difference to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(mean(abs(widc[rr]), na.rm=TRUE), 2)}
\end_layout

\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 This level of uncertainty would arise from an uncertainty in pitch of less
 than 0.01
\begin_inset Formula $^{\circ}$
\end_inset

, but the residual uncertainty may well be smaller than this because the
 mean difference in vertical wind may arise mostly from natural variability.
 
\end_layout

\begin_layout Subsubsection
Estimated uncertainty in the corrected pitch
\end_layout

\begin_layout Standard
If the uncertainty in pitch is less than about 0.01
\begin_inset Formula $^{\circ}$
\end_inset

, it may be unnecessary to refine that estimate because at that level other
 effects dominate the uncertainty in vertical wind.
 However, some additional estimates can be obtained by considering the terms
 affecting the estimates (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:full-delta-pitch"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-phi"

\end_inset

), dependent on how well the derivative of the errors in ground-speed components
 can be determined and how well this derivative can be transformed via (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:final-answer"

\end_inset

) to the reference frame of the aircraft.
 Estimates based on this approach lead to exceptionally small uncertainty
 in the pitch correction, smaller than 0.0001
\begin_inset Formula $^{\circ}$
\end_inset

, so uncertainties arising from other sources are likely dominant.
 Most sources of error, however, are addressed by the correction algorithm.
 The basic measurements from the INS are the body accelerations and body
 rotations.
 An error in the integration of the body rotations leads to an error in
 pitch that produces a false component of horizontal acceleration, so this
 will appear as an erroneous contribution to the ground-speed components
 and will be detected by the proposed algorithm.
 If the measured accelerations are in error, this leads to a position error
 and so to a pitch error, but again the erroneous accelerations are detected
 by comparison to GPS measurements and lead to a correction.
 
\end_layout

\begin_layout Standard
An error not addressed by the algorithm, however, is that arising from timing
 errors between INS and GPS.
 Especially in turns, a timing error will bias the measured errors in ground-spe
ed components and so bias the result.
 Therefore, if the samples are not synchronous they must be shifted to match.
 This can be done by minimizing the perturbations that occur in turns.
 However, even small timing differences can have serious effects on the
 correction algorithm.
 A timing delay of 10
\begin_inset space \thinspace{}
\end_inset

ms when turning at a rate of 2
\begin_inset Formula $^{\circ}$
\end_inset


\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 can lead to errors in ground-speed components of 
\begin_inset Formula $0.02\pi V/180\simeq$
\end_inset

0.08
\begin_inset space ~
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 at a representative flight speed 
\begin_inset Formula $V$
\end_inset

 of 220
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 This error changes direction at the turn rate so it leads to a false accelerati
on of about 
\begin_inset Formula $0.08\times2\pi/180\simeq0.003$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

.
 Equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:full-delta-pitch"

\end_inset

) then leads to an error in the pitch correction of about 0.015
\begin_inset Formula $^{\circ}$
\end_inset

.
 While this appears to be the dominant source of uncertainty in the pitch
 correction, it only occurs in turns and should not affect measurements
 during straight flight segments.
 
\end_layout

\begin_layout Standard
It appears appropriate to use a conservative estimate of 
\begin_inset Formula $\ll0.01{}^{\circ}$
\end_inset

 as the uncertainty to be applied to pitch.
 At this level, for the NSF/NCAR GV, the Appendix illustrates that the uncertain
ty in vertical wind is determined primarily by uncertainty in the measurement
 of angle of attack, and the pitch uncertainty is of little significance.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout

\lang english
 Modern GPS receivers, especially if augmented by special signals or special
 processing, produce 1-Hz measurements with uncertainty of around 0.03
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

[ref] The consistency of the Schuler oscillation, as illustrated by the
 top panels in Figs.
\begin_inset space ~
\end_inset

1 and 2, suggest that derivatives in velocity can be determined by averaging
 over periods of at least 10 min or more, so if the ground-speed measurements
 from the INS have uncertainty of about 0.03
\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

 (where variance spectra for the 1-Hz measurements begin to show noise),
 the uncertainty in differences between these two signals might be expected
 to be 
\begin_inset Formula $0.03\,\sqrt{2}\approx0.04$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

, and averaged over 10
\begin_inset space ~
\end_inset

min or perhaps 60 autocorrelation times the resulting difference could be
 resolved to 
\begin_inset Formula $0.04/\sqrt{60}\approx0.005$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-1}$
\end_inset

.
 Over intervals separated by 10
\begin_inset space \thinspace{}
\end_inset

min, the derivative then might be determined to 
\begin_inset Formula $0.005\times1/600\approx10^{-5}$
\end_inset


\begin_inset space \thinspace{}
\end_inset

m
\begin_inset space \thinspace{}
\end_inset

s
\begin_inset Formula $^{-2}$
\end_inset

, leading to an uncertainty in the pitch correction from (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:delta-theta"

\end_inset

) of about 10
\begin_inset Formula $^{-6}$
\end_inset

 or 0.00005
\begin_inset Formula $^{\circ}$
\end_inset

.
 S-G polynomials reduce noise in an average by a factor of 
\begin_inset Formula $\sqrt{(3(3m^{2}-7)/4m(m^{2}-4)}\simeq0.05$
\end_inset

 for m=1013 or 
\begin_inset Formula $0.06$
\end_inset

 for m=601.
 
\begin_inset Formula $0.04*0.06=0.0024$
\end_inset

m/s, 600-s separation gives acceleration uncertainty of about 
\begin_inset Formula $0.0024/600=4e-6$
\end_inset

 or pitch uncertainty of 2e-5
\begin_inset Formula $^{\circ}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The heading correction
\end_layout

\begin_layout Subsubsection
Typical magnitudes
\end_layout

\begin_layout Standard
The examples from DEEPWAVE flights 15 and 16, discussed in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Examples-roll"

\end_inset

, provide an illustration of the representative magnitude of the correction
 applied to heading.
 Unlike pitch, the heading correction does not vary with the Schuler oscillation
 but remains almost constant for most flights, with typical values of about
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(whmean15,2)}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(whmean,2)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

 for flights 15 and 16, respectively, and standard deviations in these estimates
 of about 0.01
\begin_inset Formula $^{\circ}$
\end_inset

.
 
\end_layout

\begin_layout Subsubsection
A check based on circle maneuvers
\end_layout

\begin_layout Standard
The circle maneuvers flown during flight 15 has been examined and discussed
 in some detail in 
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"

\end_inset

, Sect.
\begin_inset space ~
\end_inset

7.1.
 These flight patterns provide an alternate and independent way of estimating
 the heading error, because if the wind remains steady over the course of
 the circle then a positive heading error will lead to an erroneous eastward
 component of the wind while flying northward and a similar negative component
 when flying southward.
 A similar effect is present in the measured northward component of the
 wind.
 It is therefore possible to estimate the heading error by fitting a sinusoidal
 variation to the wind speed or to components of the wind speed.
 The result of that analysis was an indicated heading error of 
\begin_inset Formula $-$
\end_inset

0.09
\begin_inset Formula $^{\circ}$
\end_inset

, consistent with the error found here, although with a significantly larger
 uncertainty of 0.09
\begin_inset Formula $^{\circ}$
\end_inset

 arising from variations among the three circle maneuvers analyzed.
 This variation likely arose from unsteady wind conditions around the circles.
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Conclusions
\begin_inset Note Note
status open

\begin_layout Plain Layout
Keep entries with green labels empty!
\end_layout

\end_inset


\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout
Summary and conclusions
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
When a short title is given, it is used instead of the word 
\begin_inset Quotes eld
\end_inset

Conclusions
\begin_inset Quotes erd
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
An algorithm for correcting measurements of all three attitude angles (roll,
 pitch, and heading) apparently leads to significant improvement in conventional
 measurements from a high-quality inertial navigation system (INS) that
 does not use Kalman-filter updates to improve the measurements.
 The corrections are based on fits to centered portions of the flight and
 so can have advantages over recursive single-directional Kalman filters,
 and they do not require detailed knowledge of the error characteristics
 of the INS.
 In the case of pitch and roll, the procedure used neglects possible acceleromet
er biases by assuming that the velocity errors (determined by comparison
 to GPS-derived values) and attitude-angle errors are coupled via the Schuler
 oscillation.
 In the case of heading, the measured accelerations are transformed to an
 Earth-reference frame and compared to GPS measurements of acceleration,
 so this also neglects possible biases in the accelerometers.
 It is also necessary that the measurements from the INS and the GPS receiver
 be coincident in time or be shifted to coincide, preferably to a tolerance
 of around 20 ms.
 With these assumptions, corrections to pitch and roll result in residual
 uncertainties of less than 0.01
\begin_inset Formula $^{\circ}$
\end_inset

, and similar corrections to heading have uncertainty of about 0.01
\begin_inset Formula $^{\circ}$
\end_inset

 if there are periodic turns (at about 45-min intervals) that give the accelerat
ions required for this estimate.
\end_layout

\begin_layout Standard
The algorithms are documented and available as R scripts in supplementary
 material included with this paper.
 Those algorithms can be applied to past measurements as well as future
 projects to improve the measurements of wind.
 This document is constructed in ways that support duplication or extension
 of the study.
 The processing programs are incorporated into the same file that generates
 this document, using principles and techniques described by 
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a"

\end_inset

 as implemented in the R package knitr (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014b"

\end_inset

).
 The core program, AMTD-AAC.Rnw, is archived on GitHub in the directory
 at https://github.com/WilliamCooper/AMTD-AAC.git
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://github.com/WilliamCooper/AMTD-AAC.git"

\end_inset


\end_layout

\end_inset

.
 The calculations use the programming language R (
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"

\end_inset

) and were run within RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"

\end_inset

), so this is the most straightforward way to replicate the calculations
 and the generation of this document.
 An R package named Ranadu, containing auxiliary functions, is used extensively
 in the R code.
 It is available on GitHub at https://github.com/WilliamCooper/Ranadu.git
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://github.com/WilliamCooper/Ranadu.git"

\end_inset


\end_layout

\end_inset

.
 It includes functions 
\begin_inset Quotes eld
\end_inset

CorrectPitch ()
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

CorrectHeading ()
\begin_inset Quotes erd
\end_inset

 that implement the algorithms described here.
 The supplementary material also contains an extensive description of the
 workflow leading to this document.
 Finally, the data sets are archived by NCAR/EOL/RAF and are available via
 links from http://www.eol.ucar.edu/all-field-projects-and-deployments
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "this web site"
target "http://www.eol.ucar.edu/all-field-projects-and-deployments"

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
appendix%
\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary of uncertainty in wind measurements
\end_layout

\begin_layout Standard
\begin_inset FormulaMacro
\newcommand{\myparallel}{{\mkern3mu\vphantom{\perp}\vrule depth 0pt\mkern3mu\vrule depth 0pt\mkern3mu}}
\end_inset

An extensive analysis of uncertainty in the measurements of wind from the
 NSF/NCAR GV is contained in 
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"

\end_inset

.
 Here two tables from that technical note are reproduced to provide context
 for the importance of the correction procedure described in the present
 note.
 For justification of the tabulated entries and further description of the
 measuring system, that technical note should be consulted.
\end_layout

\begin_layout Standard
Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Elemental-w"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Elemental-h"

\end_inset

summarize the results for the measurements of the vertical and horizontal
 wind.
 The individual elements in the tables are standard uncertainties where
 possible.
 For horizontal wind, he elemental uncertainties are listed separately for
 the lateral (denoted 
\begin_inset Formula $\perp$
\end_inset

) and longitudinal (denoted 
\begin_inset Formula $\myparallel$
\end_inset

) components of the horizontal wind because these depend differently on
 the fundamental measurements.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang english
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Elemental contributions to the uncertainty in measurement of vertical wind
 provided by the radome-based system.
\end_layout

\end_inset


\lang british
Elemental contributions to the uncertainty in measurement of vertical wind
 provided by the radome-based system.
 Separate estimates of systematic error (bias) and random error (which is
 reduced by averaging measurements) are listed, and Type-A uncertainty estimates
 are accompanied by an estimate of the degrees of freedom (DOF) when it
 is smaller than 50.
 The last two columns represent how the tabulated uncertainties propagate
 to estimates of bias and random error in the measurement of vertical wind
 (
\begin_inset Formula $w$
\end_inset

).
 All entries pertain to 1-Hz measurements.
 Entries '--' indicate negligible contribution to uncertainty.
 
\begin_inset CommandInset label
LatexCommand label
name "tab:Elemental-w"

\end_inset

ADIFR and BDIFR are pressure measurements on the radome for angle of attack
 and sideslip, AKRD coefficients are the calibration coefficients for that
 pressure, the QCF transducer measures dynamic pressure, the PSF transducer
 measures static or ambient pressure, and ATX is the temperature measurement.
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vskip
\end_layout

\end_inset

0.1truein 
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="7">
<features rotate="0" booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
element
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
uncertainty source
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
bias
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
random
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
DOF
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $\delta w$
\end_inset

 bias
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
\begin_inset Formula $\delta w$
\end_inset

 random 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[type] 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[type] 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[m/s] 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[m/s] 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ADIFR transducer 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space ~
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space ~
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\gg$
\end_inset

50 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.05
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[B] 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AKRD coefficients 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset Formula $^{\circ}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.001
\begin_inset Formula $^{\circ}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10 / 
\begin_inset Formula $\gg$
\end_inset

50
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The two entries represent the degrees of freedom for the Type-A evaluations
 for bias and random uncertainty, respectively.
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.04 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.004
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]/[B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BDIFR transducer 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space ~
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space ~
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\gg$
\end_inset

50 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[B] 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
QCF transducer 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.3
\begin_inset space ~
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space ~
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\gg$
\end_inset

50 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<0.02 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.001
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(both)
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pitch
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
for measurement periods short compared to 
\begin_inset Formula $T_{Sch}/4$
\end_inset


\end_layout

\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.01
\begin_inset Formula $^{\circ}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.007
\begin_inset Formula $^{\circ}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $>50$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.08 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.03
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(both)
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GV vertical velocity 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.03
\begin_inset space ~
\end_inset

m/s 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<0.03
\begin_inset space ~
\end_inset

m/s 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.03 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<0.03
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[B]
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PSF transducer 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space \thinspace{}
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space \thinspace{}
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx$
\end_inset

5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(both)
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ATX 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.3
\begin_inset Formula $^{\circ}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset Formula $^{\circ}$
\end_inset

C 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\gg$
\end_inset

50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(both)
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
protect
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout

\lang english
\begin_inset Argument 1
status collapsed

\begin_layout Plain Layout

\lang english
Elemental contributions to the uncertainty in measurement of horizontal
 wind by the radome-based system.
\end_layout

\end_inset


\lang british
Elemental contributions to the uncertainty in measurement of horizontal
 wind by the radome-based system.
 Entries '--' indicate negligible contribution to uncertainty.
 Entries with subscript 
\begin_inset Formula $\perp$
\end_inset

 refer to the lateral component of the horizontal wind, and those with subscript
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

% indicating parallel 
\end_layout

\end_inset


\begin_inset Formula $\myparallel$
\end_inset

 refer to the longitudinal component (along the axis of the aircraft).
 See Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Elemental-w"

\end_inset

 for further information on the elements in this table.
 All entries apply to 1-Hz measurements.
\lang english

\begin_inset CommandInset label
LatexCommand label
name "tab:Elemental-h"

\end_inset


\lang british
The SSRD coefficients represent the calibration for sideslip in terms of
 the radome pressure measurement BDIFR, and 
\begin_inset Formula $\delta q$
\end_inset

 is the correction applied to static and dynamic pressure that represents
 the 
\begin_inset Quotes eld
\end_inset

static defect,
\begin_inset Quotes erd
\end_inset

 the difference between the measured pressure PSF and the actual pressure
 at the flight level.
 See Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Elemental-w"

\end_inset

 for explanation of some of the remaining terms.
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
vskip
\end_layout

\end_inset

0.1truein 
\begin_inset Tabular
<lyxtabular version="3" rows="22" columns="7">
<features rotate="0" booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
element
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
uncertainty
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
bias
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
random
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
DOF
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta u_{\perp,\,\myparallel}$
\end_inset

 
\series bold
bias
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta u_{\perp,\,\myparallel}$
\end_inset

 
\series bold
random 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
source
\series default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[type]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[m/s] 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[m/s] 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BDIFR 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space ~
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space ~
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\gg$
\end_inset

50 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(0.05, --)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
transducer 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SSRD 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.03
\begin_inset Formula $^{\circ}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.002
\begin_inset Formula $^{\circ}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\gg$
\end_inset

50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(0.12, --) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(0.01, --)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
coefficients
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ADIFR 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space ~
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space ~
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\gg$
\end_inset

50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
transducer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
QCF 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.3
\begin_inset space ~
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space ~
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\gg$
\end_inset

50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(see item 10) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(--, 0.15)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
transducer 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A] 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(both) 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
heading 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.09
\begin_inset Formula $^{\circ}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.04
\begin_inset Formula $^{\circ}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5/
\begin_inset Formula $\gg$
\end_inset

50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(
\begin_inset space ~
\end_inset

0.38, --) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(0.17, --)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
pitch 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.02
\begin_inset Formula $^{\circ}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.007
\begin_inset Formula $^{\circ}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $>50$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(both)
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GV horiz.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.03
\begin_inset space ~
\end_inset

m/s 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<0.03
\begin_inset space ~
\end_inset

m/s 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.03 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.03
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
velocity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[B]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[B]
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
PSF 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space \thinspace{}
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space \thinspace{}
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\approx$
\end_inset

5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
transducer 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(both)
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ATX 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.3
\begin_inset Formula $^{\circ}$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset Formula $^{\circ}$
\end_inset

C 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $>$
\end_inset

50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(--, 0.16) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(--, 0.05)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(both)
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\delta q$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.2
\begin_inset space \thinspace{}
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0.1
\begin_inset space \thinspace{}
\end_inset

hPa 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\gg$
\end_inset

50
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(--,
\begin_inset space ~
\end_inset

0.3) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(--,
\begin_inset space ~
\end_inset

0.15)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
[A]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(both)
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Acknowledgements
The instrument development and data collection were supported by the NCAR
 Earth Observing Laboratory.
 Data used in this study were collected during the DEEPWAVE field campaign
 led by Ron Smith, Dave Fritts, Jim Doyle, Mike Taylor, Steve Eckermann,
 Steve Smith, Andreas D
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
"o
\end_layout

\end_inset

rnbrack, and Michael Uddstrom.
 During this field campaign, based in New Zealand, the Research Aviation
 Facility pilots, mechanics, technicians, and software engineers operated
 the NSF/NCAR Gulfstream
\begin_inset space ~
\end_inset

GV.
 The National Center for Atmospheric Research is sponsored by the National
 Science Foundation.
 
\end_layout

\begin_layout Acknowledgements
Almost all of the analyses reported here were performed using R (
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"

\end_inset

), with RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"

\end_inset

) and knitr (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a,Xie2014b"

\end_inset

).
 The "ggplot2" package (
\begin_inset CommandInset citation
LatexCommand citet
key "wickham2009"

\end_inset

) was used for many of the figures.
 The effort to make these results reproducible benefited greatly from the
 work represented in these analysis tools, especially that provided by Y.
 Xie.
 The book by C.
 Gandrud (
\begin_inset CommandInset citation
LatexCommand citet
key "Gandrud2014"

\end_inset

) and material and presentations related to the 
\begin_inset Quotes eld
\end_inset

Geoscience Paper of the Future
\begin_inset Quotes erd
\end_inset

 (http://www.ontosoft.org/gpf/) also had a strong influence on the approach
 to this work.
\end_layout

\begin_layout Acknowledgements
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "./WAC"
options "copernicus"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<make-workflow-diagram, echo=FALSE, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

## these are saved and inserted into the workflow document
\end_layout

\begin_layout Plain Layout

library(DiagrammeR)
\end_layout

\begin_layout Plain Layout

grViz ("./DGM-PC.dot")
\end_layout

\begin_layout Plain Layout

grViz ("./DGM-HC.dot")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Figure Captions:
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:QvsQLAMS"

\end_inset

The direct measurement of dynamic pressure (
\begin_inset Formula $q_{m})$
\end_inset

 on the C-130 
\begin_inset Note Note
status open

\begin_layout Plain Layout
QCF
\end_layout

\end_inset

vs.
 that deduced using the LAMS measurement of airspeed, via Eqs.
\begin_inset space ~
\end_inset

() and ().
 All one-second-average points from one C-130 research flight on which the
 LAMS was tested (17 November 2011) are shown.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{figure}{0}%
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
thefigure{
\backslash
thesection 1}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
def
\backslash
thefigure{B1}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
appendix
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addtocounter{section}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:PtvsSSLIP"

\end_inset

The total pressure (from the sum of the ambient pressure measurement and
 the dynamic pressure measurement) on the C-130 as a function of the magnitude
 of the side-slip angle during yaw manoeuvres in which sideslip angles were
 forced by rudder action while the aircraft continued on approximately a
 straight-and-level course.
 The mean total pressure of 760.6
\begin_inset space \thinspace{}
\end_inset

hPa has been subtracted from the measurements.
 Error bars are standard deviations in the measurements for the total-pressure
 axis and are the range of the bin used in sideslip.
 Corrections for deviations from a level course and for small variations
 in airspeed have been applied, as discussed in the text.
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noappendix
\end_layout

\begin_layout Plain Layout

%
\backslash
def
\backslash
thefigure{
\backslash
addtocounter{figure}{1}
\backslash
the
\backslash
figure}%
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{figure}{0}%
\end_layout

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
thefigure}{
\backslash
arabic{figure}}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
